[{"title":"C语言的学习笔记","url":"/posts/e08a8cc7/","content":"8进制与16进制\n0x00 计算机原理01 缓冲区(buffer)与缓存(cache)buffer是内存的一部分cache是CPU，磁盘等的一部分简单来说就是buffer偏重于写，而cache偏重于读。\n02 一个程序运行时的内存空间\n\n\n\n\n\n\n\n栈区（stack）\n由编译器自动分配释放 ，存放函数的参数值，局部变量的值等\n\n\n堆区（heap）\n一般由程序员分配释放(malloc)， 若程序员不释放，程序结束时可能由OS回收\n\n\n全局区（静态区）（static）\n全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放\n\n\n文字常量区\n一般常量就是放在这里的。不能被修改。 程序结束后由系统释放\n\n\n程序代码区\n存放函数体的二进制代码\n\n\n03 ++与--的作用顺序一般来说，++a表示先算++再算a，但是，如果表达式里出现了多次变量，如++a = a + (a-1)，情况就不确定了。在使用++和--时需谨慎。\n0x01 输入专题01 scanf强烈推荐这篇博客，一定要去看看：scanf函数读取缓冲区数据的问题\n\nscanf(&quot; &quot;)；如果双引号里面的空格可以跳过广义上的空格，等价于循环+getchar\n\n正则表达式\n 参考博客\n\n[]内是匹配的字符。\n\n^表示求反集，当遇到非集合内的字符时立即终止输入。\n\n%表示选择，%* 表示跳过，其后一定要有新的%语句，否则无法读入。\n\n%,%*后面的是条件，比如%s，s是一个条件，表示任意字符。%3s又多了一个条件：只拷贝3个字符。 %[a-z]的条件稍微严格一些，输入的东西不但是字符，还得是一个小写字母的字符。 ，也就是跳过满足条件的字符，\n\n注：%[a-b 0-9]能够读入空格。单个字符也可以直接写在中括号里面\n\n\n\nfgets(c, n, fp) 与 gets 不同，第一、fgets 需要加最大输入长度n这个参量, 表示加了 \\0 之后 fgets 能读入的最大长度。因此&#x3D;&#x3D;需要在读入的最末尾主动赋值为 \\0 ，不必管是否有 \\n，这样能保证数据没有多余的 \\n&#x3D;&#x3D;\n\n对正文文件的fscanf 等函数大都和标准I&#x2F;O下的函数用法一样。除了 fgets\n\n\n02 sscanf&#x3D;&#x3D;本质上与scanf相同，只不过将目标字符串当作stdin&#x3D;&#x3D;\n同理还有sprintf\n0x02 文件专题01 fopen\nfopen 必须要搭配文件指针使用，如 fp = fopen( , ) 而且得配合 fscanf 等等，但是在关闭文件之可以同时对文件和标准输入输出进行操作。\n\n文件打开一定要判断是否成功。如果不成功，可以使用 perror(const char *s) 它可将 &#x3D;&#x3D;上一个函数(一般是各个库函数)&#x3D;&#x3D; 发生错误的原因输出到标准设备(stderr)。参数s所指的字符串会先打印出,后面再加上错误原因字符串。\n\n\n02 文本方式打开与二进制方式打开C语言采用文本方式和二进制方式打开文件的区别分析\ni. 区别数据怎么在磁盘上写不是由文件打开方式决定的，而是由写函数决定的。数据怎么从磁盘上读也不是由文件打开方式决定的，而是由读函数决定的。上面说的数据怎么写是指：一种类型的变量是怎么存的？比如int 12，可以直接存12的二进制码(4个字节)，也可以存字符‘1’，字符&#39;2&#39;.数据怎么读的是指：我要读一个int变量，是直接读sizeof(int)个字节，还是一个字符一个字符的读，直到读到的字符不是数字字符。\n这对应了两种函数\nii. 如何读写\nfread 以二进制的方式读入，fscanf 以正文方式读入。 fread 可以直接按几个字节为单位读，而 fscanf 则是把文章解释为字符串然后再读。\n\nfread 返回值是成功读入的以size为单位长度的项数\n\n\niii. 判断末尾首先说明一点，ASCII表有256个字符。\nEOF是等于-1，但是 &#x3D;&#x3D;实际上文档末尾是没有EOF这个玩意的。EOF是读入函数的返回值。&#x3D;&#x3D;在以文本方式打开的文件中，返回值为int，不会与ASCII(char类型)冲突。故EOF有效。而在以二进制打开的文件中，要想读字符，就必须得用 sizeof(char) ，这样不可避免地就会出现 EOF 与ASCII冲突。此时就得用feof来判断。\nfeof ：若为末尾返回非零，若还没到就返回0。 &#x3D;&#x3D;返回非零的触发条件和 fgets等函数返回-1的条件相同&#x3D;&#x3D;\n03 fseek 和 ftelli ftell原型如下\nlong ftell(FILE *stream);\n它的返回值为long类型，只有一个参数为文件指针\nii fseek原型如下\nint fseek (FILE * stream, long int offset, int origin );\n\n它中间的那个参数是long类型，因此中间那个参数可以这样写：22L，L表示这个整数是long类型。需要注意的是，offset移动的量永远是字节数。 &#x3D;&#x3D;由于二进制文件和文本文件存储格式的区别&#x3D;&#x3D; ，需要自己手动计算偏移量\n第三个参数只有三个值SEEK_SET表示文件开头，SEEK_CUR表示当前指针位置，SEEK_END表示文件末尾\n当offset是向文件尾方向偏移的时候，&#x3D;&#x3D;无论偏移量是否超出文件尾，fseek都是返回0&#x3D;&#x3D;，当偏移量超出文件尾的时候，文件指针是指向文件尾的。并不会返回偏移出错-1值。当offset是向文件头方向偏移的时候，如果offset没有超出文件头，fseek返回值为0.&#x3D;&#x3D;当offset超出文件头时，fseek返回出错-1值，文件指针不变还是处于原来的地址。&#x3D;&#x3D;\n\n04 fscanf与fgets与\\nfscanf遇到\\n和空格停止，但fgets会读进去。建议用fgets去除\\n，fgetc不一定行\n0x03 变量专题01 externextern a显式的说明了a的存储空间是在程序的其他地方分配的，在文件中其他位置或者其他文件中寻找a这个变量。\n02 const用const修饰的变量通常也叫常变量，因为这个变量有地址，有空间。只不过它的读写方式设定为了只读，这也就意味这只能通过赋初值的方式给它值。\n\n\n\n\nconst（运行时概念）\ndefine（编译时概念）\n\n\n\n原理\n常量声明\n字符替换\n\n\n谁来编译？\n编译器\n预编译器\n\n\n空间\n需要分配空间（C与C++中const变量内存分配问题详解)）\n不需要分配空间\n\n\n安全检查\n有类型区别，需要在编译阶段进行类型检查\n没有数据类型的区别，没有类型安全检查\n\n\n有无生命周期\n有（当前函数）\n无（全局）\n\n\n（注：const在C语言中与在C++中的内存分配方式不同。此处讨论C语言的情况）\n&#x3D;&#x3D;const修饰的全局变量，在常量区分配内存空间，不能通过变量地址来修改值；&#x3D;&#x3D;&#x3D;&#x3D;const修饰的局部变量在栈区分配内存空间，可以通过变量地址来修改值&#x3D;&#x3D;\nii 与指针搭配const的位置可以发生改变，但有可能含义就发生了变化\n例如： const int * p 和 int const * p等价，表示 *p 不能改，&#8195;&#8195;&#8195;&#8194;而 int * const p 则表示 p 不能改。\n如何记？ * 是右结合运算符，它若先和p结合，那const修饰的就是*p，否则const修饰的就是p\n03 typedeftypedef基本用法在一个定义 typedef &lt;字符串&gt; 中， &lt;字符串&gt; 中会出现一个未定义的类型名 Type_A当你写：Type_A object;  的时候，它的含义就是：用 object去替换 &lt;字符串&gt; 中的 Type_A 。\n例如：\ntypedef int int_array[4];\nint_array object;\n实际上是：用 object 替换 字符串 &quot;int int_array[4];&quot; 中的 int_array 得到的结果： int object[4];\n又例如：\ntypedef void (*PU)(int a, char b);\nPU pa;\n实际上就是用 pa 替换 void (*PU)(int a, char b); 中的 PU 。\n这也就是编译器处理tyepdef定义的原理。&#x3D;&#x3D;typedef可以看作是定义了一个新的类型，这个类型在解释的时候按照以上规则定义变量。&#x3D;&#x3D;\ntypedef与结构体搭配也可以用上面的理论解释：\n\n\n\n使用typedef关键字定义结构体类型\n定义结构体类型的同时定义结构体类型变量\n\n\n\ntypedef struct student{&#8195;int age;&#8195;int height;}std;&#x2F;&#x2F; std相当于struct student\nstruct student{&#8195;int age;&#8195;int height;}std1,std2;&#x2F;&#x2F;定义了student数据类型的结构体和std1、std2结构体变量\n\n\n04 char有符号位在x86平台上，默认有符号，但在arm平台上默认没符号。保险起见，用 signed char\n05 enum(枚举常量)定义类似于结构体相当于一次性定义多个常量。&#x3D;&#x3D;用它定义变量没用&#x3D;&#x3D;\n06 可变数组长度老师可能讲的是在C语言中不能用变量作为数组的长度，但实际上， &#x3D;&#x3D;哪怕是c89的标准，在满足一定条件时也是能够用变量作为数组长度的。&#x3D;&#x3D; \n例如：\nint len = 3;\nchar a[len];\n在语法上是没有问题的。\n尽管如此，我本人还是不推荐使用这种写法。\n\n这样写无法在定义的时候初始化。char a[len] = {0}就是错的。\n这样写只能作为局部变量，如果定义为全局变量就有问题。\n\n0x04 指针专题01  小知识点\n字符串常量有返回值，其返回值为首字母的地址\n\n数组名，是指向它的第一个一级成员的指针数组名取地址，是指向整个数组的指针\n\n\n02 表述 *(p + 1) 与 p[1] 等价本质是因为 [] 是下标运算符。 x[y] 等价于 *((x) + (y))\n03 函数指针为方便起见，C语言中可以将函数指针直接按函数调用的方式使用。比如func(u,v) 与(*func)(u,v) 等价\n最常见的例子：qsort里面的cmp函数。cmp函数的名字是你自己定的，qsort在用你写的cmp的时候先给它一个别名。这个过程就是函数A的地址通过一个函数指针的形参传递到另一个函数B内部，从而能够在内部调用。只要函数A格式与B里面的形参一样，A名字可以任何。大大增加了程序的扩展性。\n04 二维数组与二重指针见此博客具体原因是两者在内存中的分配不完全一样，二重指针更加分散一些所以 char **p 和 char p[2][3] 之间不能相互传递参数\n05 文件位置指针对文本文件的读写也是指针实现的。\n#include&lt;stdio.h>\nint main()\n&#123;\n    FILE *fp, *dd;\n    char x[100];\n    fpos_t pos[10];\n    long int pos2 = 0;\n    int top = 0;\n    int i ;\n    \n    fp = fopen(\"in.in\",\"r\");\n    //puts(\"fd\");\n    dd = fp;\n    while(feof(fp) == 0)\n    &#123;\n\t    fgetpos(fp, &amp;pos[++top]);\n\t    fgets(x, sizeof(x) / sizeof(char), fp);\n\t    //pos2 = ftell(fp);\n\t    printf(\"pos[%d]=%ld\",top, pos[top]);\n\t    puts(x);\n\t    //printf(\"pos2=%d\\n\", pos2);\n\t    //fseek(dd, pos2, SEEK_SET);\n    &#125;\n    for(i = 1; i &lt;= top; i++)\n    &#123;\n\t    fsetpos(dd, &amp;pos[i]);\n\t    fgets(x, sizeof(x) / sizeof(char), dd);\n\t    printf(\"%d:\", i);\n\t    puts(x);\n\n    &#125;\nreturn 0;\n&#125;\n\n\n\n\n\n\n0x05 结构体专题结构体大小(sizeof)sizeof计算结构体大小\n没有成员的结构体占用的空间是1个字节。\n偏移量\nstruct stru \n&#123;  \n\t\tint a;  //start address is 0\n\t\tchar b;  //start address is 4\n\t\tint c;  //start address is 8\n&#125;;\n\n偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。\n比如上面的结构体，第一个成员a的偏移量为0。第二个成员b的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员c的偏移量是第二个成员的偏移量应该是加上第二个成员的大小（4+1）。\n但在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则：（1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）（2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。\n0x06 函数专题01 qsort第一个参数是地址，注意首项零的情况第二个参数是个数qsort在调用外部判断函数的时候，传入的参数是 &#x3D;&#x3D;数组元素的地址！&#x3D;&#x3D; 。在自己写cmp函数的时候尤其要注意。另外，指针在C语言中 &#x3D;&#x3D;指向的是被指元素的首地址&#x3D;&#x3D; \n\n&#x3D;&#x3D;qsort默认从小到大排序，若cmp返回值大于0则交换，小于等于0不管。通常直接写return a - b;&#x3D;&#x3D;\n一维的数组排序\nint a[1000]\nqsort(a,1000,sizeof(int),comp);\n\nint comp(const void *a,const void *b)\n&#123;\n  return *(int *)a-*(int *)b;\n&#125; \n-----------------------------------\n\n字符数组排序\nchar a[1000][20];\nqsort(a,1000,sizeof(char)*20,comp);\nint comp(const void *a,const void *b)\n&#123;\n   return strcmp((char *)a,(char *)b);\n&#125;\n-----------------------------------\n\n结构体排序\ntypedef struct str\n&#123;\n   char str1[11];\n   char str2[11];\n&#125;str;\n\nstr *strs;strs=(str *)malloc(sizeof(str)*10);\nint compare(const void *a,const void *b)\n&#123;\n  return strcmp(((str*)a)->str2,((str*)b)->str2);\n&#125;\nqsort(strs,10,sizeof(str),compare); \n\n\n02 strlen()返回值为无符号整形unsigned int。故如果参与减法运算会产生负数，需要强制类型转换\n03 内存分配函数i malloc()\n\n\n功能\n申请堆内存\n\n\n\n所需头文件\n#include&lt;stdlib.h&gt;\n\n\n函数原型\nvoid *malloc(size_t,size);\n\n\n参数(size)\n所申请的一块堆内存的大小，单位是字节\n\n\n返回值\n成功 - 指向分配好的堆内存的指针失败 - NULL\n\n\nmalloc()分配给定大小（以字节为单位）的内存块，并返回一个指向块开头的指针。malloc()不会初始化分配的内存。如果在初始化之前我们尝试访问内存块的内容，那么我们将得到分段错误（或者可能是垃圾值）。\n\n\n\nii calloc()\n\n\n功能\n申请堆内存\n\n\n\n所需头文件\n#include&lt;stdlib.h&gt;\n\n\n函数原型\nvoid *calloc(size_t count,size_t size);\n\n\n参数(count与size)\nsize —- 所申请的一块堆内存的大小，单位是字节count —- 所申请的堆内存的块数，所有的内存块是连续分布的，无间隔的\n\n\n返回值\n成功 - 指向分配好的堆内存的指针失败 - NULL\n\n\ncalloc()分配内存并将分配的内存块初始化为零。如果我们尝试访问这些块的内容，那么我们将得到 0。\n\n\n\n0x07 宏定义专题（待整理）宏定义详解\n","categories":["article"],"tags":["C"]},{"title":"Matlab中的plot函数","url":"/posts/c31a0829/","content":"subplotmatlabl中subplot(1,2,1)意思在MATLAB中，subplot(0函数用于在同一图中绘制多个子图。其中，括号中的参数表示子图的排列方式。例如，subplot(121)表示将当前图分成一行两列，当前绘图窗口的第一个子图。具体解释如下：\n\n第一个参数1表示图形总行数为1\n第二个参数2表示图形总列数为2\n第三个参数1表示当前绘制的子图为第1个因此，subplot(1,2,1)的作用是将当前绘图窗口划分为1行2列，然后在第1个子图上进行绘制。\n\nplot 改线宽、线型、颜色plot(x1,y1,...,xn,yn,&#39;LineWidth&#39;,4)\n线型 线方式： - 实线 :点线 -. 虚点线 -- 波折线。 \n线型 点方式： . 圆点 +加号 * 星号 x x形 o 小圆\n颜色： y黄； r红； g绿； b蓝； w白； k黑； m紫； c青.\n比如：plot(t,y(:,1),&#39;-o&#39;,t,y(:,2),&#39;r&#39;)\n加图例，改标题都是在plot命令之后另起一行。\nlegend(&#39;x&#39;,&#39;y&#39;,&#39;z&#39;);表示第1个线标x的图例。\nxlabel(&#39;xxxx&#39;)表示当前plot的x坐标文字。\nfigure对象, axis, plotf1 = figure(1);\nax1 = axes(f1);axes只能在figure已经创建的情况下才能用，如果关闭了之间的窗口，这个命令就不能用。\n","categories":["article"],"tags":["Matlab"]},{"title":"PRESTO的配置（高算版）","url":"/posts/3da3d5a5/","content":"作者为：левский Уильямс\n一、准备工作在配置安装的时候，没有load任何的Module。如果在此之前有导入过任何的模块（用module list查看已导入的模块），请全部卸载。\n保证gcc是4.8.5版本的。\n需要下载如下的工具：\n\nfftw-3.3.9 (点击下载)\npgplot5.2 (点击下载，有点慢)\ntempo (点击下载)\ncfitsio-4.0.0 (点击下载) (注意其大小只有4M左右，如果不是4M左右肯定是下错了)\npresto (点击下载)\n\n数据集下载如下：\nGBT_Lband_PSR.fil\n\n**注：**如果想自己下载，可以参考下面的链接\nfftw-3.3.9\nwget http://www.fftw.org/fftw-3.3.9.tar.gz\n\npgplot：\nwget ftp://ftp.astro.caltech.edu/pub/pgplot/pgplot5.2.tar.gz\n\ntempo：\ngit clone git://git.code.sf.net/p/tempo/tempo\ncfitsio\nwget http://heasarc.gsfc.nasa.gov/FTP/software/fitsio/c/cfitsio-4.0.0.tar.gz\npresto\ngit clone git:&#x2F;&#x2F;github.com&#x2F;scottransom&#x2F;presto\n网络方面的问题请自己想办法(ง •_•)ง\n需要会的基本命令与操作\nvim：点击学习\nLinux下路径的基本操作：点击学习\nBash中的变量：了解，了解2\n如何添加环境变量：点击学习\nmake如何工作：了解\n\n二、正式安装再强调一遍，在配置安装的时候，没有load任何的Module。如果在此之前有导入过任何的模块（用module list查看已导入的模块），请全部卸载。\n在正式安装之前，我建议把源码目录和安装目录分开，像下面这样的一个文件树是比较推荐的。\n之后所有的指令都是基于下面这个文件结构来的。\n~ # 用户根目录\n├── Data # 数据集存放目录\n│   └── GBT_Lband_PSR.fil\n├── Downloads # 源码目录\n│   ├── cfitsio\n│   ├── fftw\n│   ├── pgplot\n│   ├── presto\n│   └── tempo\n└── Program_Files # 安装目录\n    ├── cfitsio\n    ├── fftw\n    ├── pgplot\n    ├── presto\n    └── tempo\n\n也就是说，需要在用户根目录下(~)新建3个文件夹：Data、Downloads、Program_Files相。新建完之后，需要在安装目录里(Program_Files)新建5个文件夹。\n在上面这个文件目录下，需要添加的环境变量如下：(如果看不懂没关系，那就先跳到下面正式安装部分)\nexport LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$&#123;HOME&#125;/Program_Files/fftw/lib/\" # 这里$&#123;HOME&#125;是你用户的根目录\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$&#123;HOME&#125;/Program_Files/fftw/lib/pkgconfig\"\nexport PATH=\"$PATH:$&#123;HOME&#125;/Program_Files/fftw/bin\"\nexport C_INCLUDE_PATH=\"$C_INCLUDE_PATH:$&#123;HOME&#125;/Program_Files/fftw/include\"\nexport CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH:$&#123;HOME&#125;/Program_Files/fftw/include\"\n\nexport PGPLOT_DIR=\"$&#123;HOME&#125;/Program_Files/pgplot/\" \nexport LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$&#123;HOME&#125;/Program_Files/pgplot/\"   # 注意：没有lib的子文件夹\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$&#123;HOME&#125;/Program_Files/pgplot/lib/pkgconfig\"\n\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$&#123;HOME&#125;/Program_Files/tempo/lib/pkgconfig\" \nexport TEMPO=\"$&#123;HOME&#125;/Program_Files/tempo\" \n\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$&#123;HOME&#125;/Program_Files/cfitsio/lib/pkgconfig\"\nexport LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$&#123;HOME&#125;/Program_Files/cfitsio/lib\"\n\nexport PRESTO=\"$&#123;HOME&#125;/Downloads/presto/\" \nexport LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$&#123;HOME&#125;/Downloads/presto/lib\" \n\nexport PATH=\"$PATH:$&#123;HOME&#125;/Downloads/presto/bin\" # 注意，这条是在源码目录下！！！\nexport C_INCLUDE_PATH=\"$C_INCLUDE_PATH:$&#123;HOME&#125;/Program_Files/presto/include\"\nexport CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH:$&#123;HOME&#125;/Program_Files/presto/include\"\n\n\n注： 直接加在~/.bashrc里有风险，可以参考： bashrc改不改?\n\n1.fftw安装fftw.第1步：安装进入fftw的源码根目录，然后依次执行如下命令：（如果不知道源码根目录在哪里，看看上面。）\n./configure --enable-shared --enable-single --prefix=\"$&#123;HOME&#125;/Program_Files/fftw\"\nmake \nmake install\n\n通常来说，第1个安装包的安装都是顺利的。\n\n有几点需要说明：\n\n此处用make -j4可能会报错。如果执行make报错，就执行一下make clean，清理掉编译错误的文件之后再执行make\n\n\nfftw.第2步：添加环境变量加入环境变量直接在终端里执行下面的指令，仅当前shell有效，退出或者重连之后就失效。而我们需要环境变量一直存在，因此把下面的指令追加到~/.bashrc文件末尾 ^note\n然后再重新载入.bashrc（重新载入需要在终端里执行source ~/.bashrc）\n具体来说，就是：\n# 第1步，打开.bashrc\nvim ~/.bashrc   \n\n# 第2步，把如下行加到.bashrc的末尾\nexport LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$&#123;HOME&#125;/Program_Files/fftw/lib/\" # 这里$&#123;HOME&#125;是你用户的根目录\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$&#123;HOME&#125;/Program_Files/fftw/lib/pkgconfig\"\nexport PATH=\"$PATH:$&#123;HOME&#125;/Program_Files/fftw/bin\"\nexport C_INCLUDE_PATH=\"$C_INCLUDE_PATH:$&#123;HOME&#125;/Program_Files/fftw/include\"\nexport C_INCLUDE_PATH=\"$C_INCLUDE_PATH:$&#123;HOME&#125;/Program_Files/presto/include\"\n# 如果写在~/.bashrc里，记得source ~/.bashrc\n\n# 第3步，重新载入.bashrc\nsource ~/.bashrc   \n2.pgplot的安装pgplot.第1步：移动1个文件到安装目录现在请切换到pgplot的源码根目录(~/Downloads/pgplot)\n执行下面的命令以备份相关文件\n##### 如果想直接复制粘贴，请确保你当前的目录是pgplot的源码的根目录!\ncp drivers.list ~/Program_Files/pgplot/drivers.list\n\npgplot.第2步：修改3个文件用vim打开安装目录下~/Program_Files/pgplot下面的drivers.list文件，也就是执行vim drivers.list，然后把下面这几行前面的!去掉\n# 去掉这几行前面的感叹号\n\n　  GIDRIV 1 /GIF GIF-format file, landscape                            # line 19\n　　GIDRIV 2 /VGIF GIF-format file, portrait                            # line 20\n　　NUDRIV 0 /NULL Null device (no output) Std F77                      # line 38\n　　PSDRIV 1 /PS PostScript printers, monochrome, landscape Std F77     # line 44\n　　PSDRIV 2 /VPS Postscript printers, monochrome, portrait Std F77     # line 45\n　　PSDRIV 3 /CPS PostScript printers, color, landscape Std F77         # line 46\n　　PSDRIV 4 /VCPS PostScript printers, color, portrait Std F77         # line 47\n　　XWDRIV 1 /XWINDOW Workstations running X Window System C            # line 71\n　　XWDRIV 2 /XSERVE Persistent window on X Window System C             # line 72\n然后保存并退出——:wq\n用vim打开~/Downloads/pgplot/src/grpckg1.inc文件，然后对第29行作如下修改\n# Replace \" PARAMETER (GRIMAX = 8) \" in line 29\n#    by   \" PARAMETER (GRIMAX = 32) \"\n然后保存并退出——:wq\n用vim打开~/Downloads/pgplot/src/pgplot.inc文件，然后对第7行作如下修改\n# Replace \" PARAMETER (PGMAXD=8) \" in line 7\n#    by   \" PARAMETER (PGMAXD=32) \"\n然后保存并退出——:wq\npgplot.第3步：安装前的配置现在请切换到pgplot的安装目录(~/Program_Files/pgplot)\n在安装目录运行位于源码目录里的makemake，并执行2遍。\n# 目录结构见本文开头\n~/Downloads/pgplot/makemake ~/Downloads/pgplot linux g77_gcc\n~/Downloads/pgplot/makemake ~/Downloads/pgplot linux g77_gcc\n\n注：\n上面的命令是可以正常执行的。不要看见makemake前面有一堆路径就觉得这个写的有问题。只需要把对应文件的路径换成你自己的路径。\n如果报错说Permission denied，说明你的makemake没有可执行权限。执行下面的指令以加上：\nchmod +x ~/Downloads/pgplot/makemake\n如遇其它文件没有权限，类似处理。\n\n执行完毕之后安装目录下会出现如下的文件：（如果你安装文件夹和我开头写的是一样的结构的话）\ndrivers.list   grexec.f   grpckg1.inc   makefile   pgplot.inc   rgb.txt\n\n然后更改makefile文件的第25和第26行\n# Replace \"FCOMPL=g77\"       in line 25 \n#   by    \"FCOMPL=gfortran\" \n# \n# Replace \"FFLAGC=-u -Wall -fPIC -O\" in line 26\n#   by    \"FFLAGC=-ffixed-form -ffixed-line-length-none -u -Wall -fPIC -O\"\npgplot.第4步，安装# 在安装目录下执行\nmake\nmake cpg\n\n如果make报错，make clean之后再运行一次试试。\n\n注： 如果需要编译pgplot.html，需要更改~/Downloads/pgplot/makehtml文件。只需要把第1行替换为这个：\n#!/usr/bin/perl\n然后：\n# 在安装目录下执行\nmake pgplot.html\npgplot.第5步，添加环境变量export PGPLOT_DIR=\"$&#123;HOME&#125;/Program_Files/pgplot/\" # 记得替换USER为自己的用户名\nexport LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$&#123;HOME&#125;/Program_Files/pgplot/\"   # 注意：没有lib的子文件夹\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$&#123;HOME&#125;/Program_Files/pgplot/lib/pkgconfig\"\n\n# 如果写在~/.bashrc里，记得source ~/.bashrc\n\n\n注：\npgplot有一些demo可以运行。只需要切换到安装目录，运行./pgdemo1，弹出如下信息可说明pgplot正常安装\nGraphcs device/type (? to see list, default /Xserve):\n# 或 Graphcs device/type (? to see list, default /NULL):\n3.Tempo安装tempo.第1步：安装前的准备现在请切换到Tempo的源码根目录(~/Downloads/tempo)\n可以尝试运行源码根目录下的prepare，像这样：\n./prepare   # 一般无法正常运行\n如果可以正常工作，就跳到下一步，否则就别执行那个prepare了，改成执行如下的操作：\nautoreconf --install\n\n另外需要把./src/get_version_id.sh加上执行权限，并把它的file format改成Unix。（用下面的dos2unix，服务器上自带）\nchmod +x ./src/get_version_id.sh\ndos2unix ./src/get_version_id.sh\ndos2unix ./configure.ac\n\ntempo.第2步：正式安装./configure --prefix=\"$&#123;HOME&#125;/Program_Files/tempo\"\nmake \nmake install\n\n\n注：\n如果之间那步没有把configure.ac转换成unix格式，configure之后会报错，此时重新运行configure是没有用的，需要按如下方法运行\ndos2unux ./configure.ac\naclocal\nautoconf\nautomake -a\n./configure --prefix=\"$&#123;HOME&#125;/Program_Files/tempo\"\n之后再继续make和make install即可\n\ntempo.第3步：添加环境export PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$&#123;HOME&#125;/Program_Files/tempo/lib/pkgconfig\" \nexport TEMPO=\"$&#123;HOME&#125;/Program_Files/tempo\" \n# 如果写在~/.bashrc里，记得source ~/.bashrc\n\n4.cfitsio安装cfitsio.第1步：安装现在请切换到cfitsio的源码根目录(~/Downloads/cfitsio)\n./configure --prefix=\"$&#123;HOME&#125;/Program_Files/cfitsio\" \nmake \nmake install\n\ncfitsio.第2步：添加环境变量\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$&#123;HOME&#125;/Program_Files/cfitsio/lib/pkgconfig\"\nexport LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$&#123;HOME&#125;/Program_Files/cfitsio/lib\"\n# 如果写在~/.bashrc里，记得source ~/.bashrc\n5.安装PRESTOpresto.第1步：添加安装用的环境变量export PRESTO=\"$&#123;HOME&#125;/Downloads/presto/\" # 把USER替换为你的用户名\nexport LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$&#123;HOME&#125;/Downloads/presto/lib\" \n# 如果写在~/.bashrc里，记得source ~/.bashrc\n\npresto.第2步：修改1个文件现在请切换到presto下的src目录(~/Downloads/presto/src)\n打开./realfft.c，编辑第70行，\n# 改前\n...\nfor (int fi = 0 ; fi &lt; numfiles ; fi++) &#123;\n...\n\n\n\n# 改后\n...\nint fi;\nfor (fi = 0 ; fi &lt; numfiles ; fi++) &#123;\n...\n\n\npresto.第3步：安装保持在presto下的src目录(~/Downloads/presto/src)\nmake makewisdom\nmake prep\nmake    # 目前只能安装在源码目录下\n\n# 下面这两行本来也是安装的步骤，但服务器没网就算了，不影响\ncd $PRESTO\npip install .\n\npresto.第4步：添加环境变量export PATH=\"$PATH:$&#123;HOME&#125;/Downloads/presto/bin\" # 注意，这条是在源码目录下！！！\nexport CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH:$&#123;HOME&#125;/Program_Files/fftw/include\"\nexport CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH:$&#123;HOME&#125;/Program_Files/presto/include\"\n# 如果写在~/.bashrc里，记得source ~/.bashrc\n\n到目前为止，你应该正确安装了presto。下面我们进行一些验证。输入readfile --help，应该有如下的输出\nreadfile: unknown option `--help'\n\n   [-page] [-byte] [-b] [-float] [-f] [-double] [-d] [-fcomplex] [-fc] [-dcomplex] [-dc] [-short] [-s] [-int] [-i] [-long] [-l] [-rzwcand] [-rzw] [-bincand] [-bin] [-position] [-pos] [-pkmb] [-bcpm] [-wapp] [-spigot] [-filterbank] [-psrfits] [-fortran] [-index [index]] [-nph nph] [--] file\n      Reads raw data from a binary file and displays it on stdout.\n          -page: Paginate the output like 'more'\n          -byte: Raw data in byte format\n             -b: Raw data in byte format\n         -float: Raw data in floating point format\n             -f: Raw data in floating point format\n        -double: Raw data in double precision format\n             -d: Raw data in double precision format\n      -fcomplex: Raw data in float-complex format\n            -fc: Raw data in float-complex format\n      -dcomplex: Raw data in double-complex format\n            -dc: Raw data in double-complex format\n         -short: Raw data in short format\n             -s: Raw data in short format\n           -int: Raw data in integer format\n             -i: Raw data in integer format\n          -long: Raw data in long format\n             -l: Raw data in long format\n       -rzwcand: Raw data in rzw search candidate format\n           -rzw: Raw data in rzw search candidate format\n       -bincand: Raw data in bin search candidate format\n           -bin: Raw data in bin search candidate format\n      -position: Raw data in position struct format\n           -pos: Raw data in position struct format\n          -pkmb: Raw data in Parkes Multibeam format\n          -bcpm: Raw data in BCPM format\n          -wapp: Raw data in WAPP format\n        -spigot: Raw data in Spigot Card format\n    -filterbank: Raw data in SIGPROC filterbank format\n       -psrfits: Raw data in PSRFITS format\n       -fortran: Raw data was written by a fortran program\n         -index: The range of objects to display\n                 0...2 int values between -1 and oo\n                 default: `0' ` -1'\n           -nph: 0th FFT bin amplitude (for 'RZW' data)\n                 1 double value\n                 default: `1.0'\n           file: Input data file name.\n                 1 value\n  version: 12Mar10\n\n如果有这些输出，就说明是成功安装了\n三、跑数据集跑数据集的第1步：预处理在数据目录(~/Data/)下执行如下指令\nreadfile ~/Data/GBT_Lband_PSR.fil\nrfifind -time 1.0 -o Lband ~/Data/GBT_Lband_PSR.fil\nprepdata -nobary -o ~/Data/Lband_topo_DM0.00 -dm 0.0 -mask ~/Data/Lband_rfifind.mask ~/Data/GBT_Lband_PSR.fil\n\n跑数据集的第2步：写脚本编写如下的脚本，注意保存的后缀需要是*.slurm（可以取名为run.slurm）：\n#!/bin/bash\n#SBATCH -J presto\n#SBATCH -p cpu-low\n#SBATCH -N 2\n#SBATCH -n 16\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 5:00\n#SBATCH -o run.out\n#SBATCH -e run.err\n\nmodule load intel/18.0.3.222\n\ncd $PRESTO/tests/\nmpirun -np 2 accelsearch -numharm 4 -zmax 0 \"$&#123;HOME&#125;/Data/Lband_topo_DM0.00.dat\" -ncpus 8\n\n然后，我们可以先在本地试试脚本能不能正常运行。在终端里输入如下：\nbash ./run.slurm 1>run.out 2>run.err # 假设你保存的脚本叫run.slurm\n\n如果run.err大小为0b，0K，说明没有问题，那么就放心提交作业吧!\n\n注：命令含义解释\n1&gt;run.out表示把脚本的执行的正常输出写到run.out文件，尖括号左右不要有空格\n2&gt;run.err表示把脚本的执行的错误输出写到run.err文件，尖括号左右不要有空格\n\n跑数据集的第3步：提交如果在上面你脚本里Lband_topo_DM0.00.dat用的是绝对路径，那么在这一步你的slurm脚本就可以随便放。\n在你放脚本的地方执行如下指令：\nsbatch run.slurm # 提交作业脚本\n如果正常提交，会有如下的结果：\n[para_xxxxxxxx@ln04 ~]$ sbatch run.slurm\nSubmitted batch job xxxxxxxx        # 仅表示成功提交\n\n至于运行的结果，则需要在run.out和run.err里面看了。（对应你slurm脚本的#SBATCH -o run.out和#SBATCH -e run.err）\n至于其它的问题，请自己解决吧，因为我也没有解决（笑\n参考文献CentOS 7 安装 pgplot\nPRESTO指导手册中文版\n脉冲星PRESTO部署文档\n","categories":["教程"],"tags":["HPC","linux","instruction"]},{"title":"Scoop,winget等的配置","url":"/posts/f8ec0409/","content":"Wingetwinget settings可以打开设置json文件。其中与安装有关的部分如下\n&#123;\n\t...\n\t\n\"installBehavior\": &#123;\n        \"defaultInstallRoot\": \"...\",\n        \"portablePackageUserRoot\": \"...\",\n        \"portablePackageMachineRoot\": \"...\"\n    &#125;,\n\n    ...\n&#125;\n\n第1个是默认的安装路径，但我自己用下来不太实用，还不如用-i参数图形化安装。第2个和第3个参数有用，安装一些直接运行的软件（如wget）时就会用这个参数。\nScoopScoop 修改其根目录，只需要新建系统级环境变量 SCOOP，之后再用脚本安装即可。\n\nps1脚本内容如下：\n\n# Issue Tracker: https://github.com/ScoopInstaller/Install/issues\n# Unlicense License:\n#\n# This is free and unencumbered software released into the public domain.\n#\n# Anyone is free to copy, modify, publish, use, compile, sell, or\n# distribute this software, either in source code form or as a compiled\n# binary, for any purpose, commercial or non-commercial, and by any\n# means.\n#\n# In jurisdictions that recognize copyright laws, the author or authors\n# of this software dedicate any and all copyright interest in the\n# software to the public domain. We make this dedication for the benefit\n# of the public at large and to the detriment of our heirs and\n# successors. We intend this dedication to be an overt act of\n# relinquishment in perpetuity of all present and future rights to this\n# software under copyright law.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n# OTHER DEALINGS IN THE SOFTWARE.\n#\n# For more information, please refer to \n\n&lt;#.SYNOPSIS    Scoop installer..DESCRIPTION    The installer of Scoop. For details please check the website and wiki..PARAMETER ScoopDir    Specifies Scoop root path.    If not specified, Scoop will be installed to ‘$env:USERPROFILE\\scoop’..PARAMETER ScoopGlobalDir    Specifies directory to store global apps.    If not specified, global apps will be installed to ‘$env:ProgramData\\scoop’..PARAMETER ScoopCacheDir    Specifies cache directory.    If not specified, caches will be downloaded to ‘$ScoopDir\\cache’..PARAMETER NoProxy    Bypass system proxy during the installation..PARAMETER Proxy    Specifies proxy to use during the installation..PARAMETER ProxyCredential    Specifies credential for the given proxy..PARAMETER ProxyUseDefaultCredentials    Use the credentials of the current user for the proxy server that is specified by the -Proxy parameter..PARAMETER RunAsAdmin    Force to run the installer as administrator..LINK    https://scoop.sh.LINK    https://github.com/ScoopInstaller/Scoop/wiki#&gt;param(    [String] $ScoopDir,    [String] $ScoopGlobalDir,    [String] $ScoopCacheDir,    [Switch] $NoProxy,    [Uri] $Proxy,    [System.Management.Automation.PSCredential] $ProxyCredential,    [Switch] $ProxyUseDefaultCredentials,    [Switch] $RunAsAdmin)\nDisable StrictMode in this scriptSet-StrictMode -Off\nfunction Write-InstallInfo {    param(        [Parameter(Mandatory &#x3D; $True, Position &#x3D; 0)]        [String] $String,        [Parameter(Mandatory &#x3D; $False, Position &#x3D; 1)]        [System.ConsoleColor] $ForegroundColor &#x3D; $host.UI.RawUI.ForegroundColor    )\n$backup = $host.UI.RawUI.ForegroundColor\n\nif ($ForegroundColor -ne $host.UI.RawUI.ForegroundColor) {\n    $host.UI.RawUI.ForegroundColor = $ForegroundColor\n}\n\nWrite-Output &quot;$String&quot;\n\n$host.UI.RawUI.ForegroundColor = $backup\n\n}\nfunction Deny-Install {    param(        [String] $message,        [Int] $errorCode &#x3D; 1    )\nWrite-InstallInfo -String $message -ForegroundColor DarkRed\nWrite-InstallInfo &#39;Abort.&#39;\n\n# Don&#39;t abort if invoked with iex that would close the PS session\nif ($IS_EXECUTED_FROM_IEX) {\n    break\n} else {\n    exit $errorCode\n}\n\n}\nfunction Test-LanguageMode {    if ($ExecutionContext.SessionState.LanguageMode -ne ‘FullLanguage’) {        Write-Output ‘Scoop requires PowerShell FullLanguage mode to run, current PowerShell environment is restricted.’        Write-Output ‘Abort.’\n    if ($IS_EXECUTED_FROM_IEX) {\n        break\n    } else {\n        exit $errorCode\n    }\n}\n\n}\nfunction Test-ValidateParameter {    if ($null -eq $Proxy -and ($null -ne $ProxyCredential -or $ProxyUseDefaultCredentials)) {        Deny-Install ‘Provide a valid proxy URI for the -Proxy parameter when using the -ProxyCredential or -ProxyUseDefaultCredentials.’    }\nif ($ProxyUseDefaultCredentials -and $null -ne $ProxyCredential) {\n    Deny-Install &quot;ProxyUseDefaultCredentials is conflict with ProxyCredential. Don&#39;t use the -ProxyCredential and -ProxyUseDefaultCredentials together.&quot;\n}\n\n}\nfunction Test-IsAdministrator {    return ([Security.Principal.WindowsPrincipal]             [Security.Principal.WindowsIdentity]::GetCurrent()    ).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)}\nfunction Test-Prerequisite {    # Scoop requires PowerShell 5 at least    if (($PSVersionTable.PSVersion.Major) -lt 5) {        Deny-Install ‘PowerShell 5 or later is required to run Scoop. Go to https://microsoft.com/powershell to get the latest version of PowerShell.’    }\n# Scoop requires TLS 1.2 SecurityProtocol, which exists in .NET Framework 4.5+\nif ([System.Enum]::GetNames([System.Net.SecurityProtocolType]) -notcontains &#39;Tls12&#39;) {\n    Deny-Install &#39;Scoop requires .NET Framework 4.5+ to work. Go to https://microsoft.com/net/download to get the latest version of .NET Framework.&#39;\n}\n\n# Ensure Robocopy.exe is accessible\nif (!(Test-CommandAvailable(&#39;robocopy&#39;))) {\n    Deny-Install &quot;Scoop requires &#39;C:\\Windows\\System32\\Robocopy.exe&#39; to work. Please make sure &#39;C:\\Windows\\System32&#39; is in your PATH.&quot;\n}\n\n# Detect if RunAsAdministrator, there is no need to run as administrator when installing Scoop\nif (!$RunAsAdmin -and (Test-IsAdministrator)) {\n    # Exception: Windows Sandbox, GitHub Actions CI\n    $exception = ($env:USERNAME -eq &#39;WDAGUtilityAccount&#39;) -or ($env:GITHUB_ACTIONS -eq &#39;true&#39; -and $env:CI -eq &#39;true&#39;)\n    if (!$exception) {\n        Deny-Install &#39;Running the installer as administrator is disabled by default, see https://github.com/ScoopInstaller/Install#for-admin for details.&#39;\n    }\n}\n\n# Show notification to change execution policy\n$allowedExecutionPolicy = @(&#39;Unrestricted&#39;, &#39;RemoteSigned&#39;, &#39;ByPass&#39;)\nif ((Get-ExecutionPolicy).ToString() -notin $allowedExecutionPolicy) {\n    Deny-Install &quot;PowerShell requires an execution policy in [$($allowedExecutionPolicy -join &#39;, &#39;)] to run Scoop. For example, to set the execution policy to &#39;RemoteSigned&#39; please run &#39;Set-ExecutionPolicy RemoteSigned -Scope CurrentUser&#39;.&quot;\n}\n\n# Test if scoop is installed, by checking if scoop command exists.\nif (Test-CommandAvailable(&#39;scoop&#39;)) {\n    Deny-Install &quot;Scoop is already installed. Run &#39;scoop update&#39; to get the latest version.&quot;\n}\n\n}\nfunction Optimize-SecurityProtocol {    # .NET Framework 4.7+ has a default security protocol called ‘SystemDefault’,    # which allows the operating system to choose the best protocol to use.    # If SecurityProtocolType contains ‘SystemDefault’ (means .NET4.7+ detected)    # and the value of SecurityProtocol is ‘SystemDefault’, just do nothing on SecurityProtocol,    # ‘SystemDefault’ will use TLS 1.2 if the webrequest requires.    $isNewerNetFramework &#x3D; ([System.Enum]::GetNames([System.Net.SecurityProtocolType]) -contains ‘SystemDefault’)    $isSystemDefault &#x3D; ([System.Net.ServicePointManager]::SecurityProtocol.Equals([System.Net.SecurityProtocolType]::SystemDefault))\n# If not, change it to support TLS 1.2\nif (!($isNewerNetFramework -and $isSystemDefault)) {\n    # Set to TLS 1.2 (3072), then TLS 1.1 (768), and TLS 1.0 (192). Ssl3 has been superseded,\n    # https://docs.microsoft.com/en-us/dotnet/api/system.net.securityprotocoltype?view=netframework-4.5\n    [System.Net.ServicePointManager]::SecurityProtocol = 3072 -bor 768 -bor 192\n    Write-Verbose &#39;SecurityProtocol has been updated to support TLS 1.2&#39;\n}\n\n}\nfunction Get-Downloader {    $downloadSession &#x3D; New-Object System.Net.WebClient\n# Set proxy to null if NoProxy is specificed\nif ($NoProxy) {\n    $downloadSession.Proxy = $null\n} elseif ($Proxy) {\n    # Prepend protocol if not provided\n    if (!$Proxy.IsAbsoluteUri) {\n        $Proxy = New-Object System.Uri(&#39;http://&#39; + $Proxy.OriginalString)\n    }\n\n    $Proxy = New-Object System.Net.WebProxy($Proxy)\n\n    if ($null -ne $ProxyCredential) {\n        $Proxy.Credentials = $ProxyCredential.GetNetworkCredential()\n    } elseif ($ProxyUseDefaultCredentials) {\n        $Proxy.UseDefaultCredentials = $true\n    }\n\n    $downloadSession.Proxy = $Proxy\n}\n\nreturn $downloadSession\n\n}\nfunction Test-isFileLocked {    param(        [String] $path    )\n$file = New-Object System.IO.FileInfo $path\n\nif (!(Test-Path $path)) {\n    return $false\n}\n\ntry {\n    $stream = $file.Open(\n        [System.IO.FileMode]::Open,\n        [System.IO.FileAccess]::ReadWrite,\n        [System.IO.FileShare]::None\n    )\n    if ($stream) {\n        $stream.Close()\n    }\n    return $false\n} catch {\n    # The file is locked by a process.\n    return $true\n}\n\n}\nfunction Expand-ZipArchive {    param(        [String] $path,        [String] $to    )\nif (!(Test-Path $path)) {\n    Deny-Install &quot;Unzip failed: can&#39;t find $path to unzip.&quot;\n}\n\n# Check if the zip file is locked, by antivirus software for example\n$retries = 0\nwhile ($retries -le 10) {\n    if ($retries -eq 10) {\n        Deny-Install &quot;Unzip failed: can&#39;t unzip because a process is locking the file.&quot;\n    }\n    if (Test-isFileLocked $path) {\n        Write-InstallInfo &quot;Waiting for $path to be unlocked by another process... ($retries/10)&quot;\n        $retries++\n        Start-Sleep -Seconds 2\n    } else {\n        break\n    }\n}\n\n# Workaround to suspend Expand-Archive verbose output,\n# upstream issue: https://github.com/PowerShell/Microsoft.PowerShell.Archive/issues/98\n$oldVerbosePreference = $VerbosePreference\n$global:VerbosePreference = &#39;SilentlyContinue&#39;\n\n# Disable progress bar to gain performance\n$oldProgressPreference = $ProgressPreference\n$global:ProgressPreference = &#39;SilentlyContinue&#39;\n\n# PowerShell 5+: use Expand-Archive to extract zip files\nMicrosoft.PowerShell.Archive\\Expand-Archive -Path $path -DestinationPath $to -Force\n$global:VerbosePreference = $oldVerbosePreference\n$global:ProgressPreference = $oldProgressPreference\n\n}\nfunction Out-UTF8File {    param(        [Parameter(Mandatory &#x3D; $True, Position &#x3D; 0)]        [Alias(‘Path’)]        [String] $FilePath,        [Switch] $Append,        [Switch] $NoNewLine,        [Parameter(ValueFromPipeline &#x3D; $True)]        [PSObject] $InputObject    )    process {        if ($Append) {            [System.IO.File]::AppendAllText($FilePath, $InputObject)        } else {            if (!$NoNewLine) {                # Ref: https://stackoverflow.com/questions/5596982                # Performance Note: WriteAllLines throttles memory usage while                # WriteAllText needs to keep the complete string in memory.                [System.IO.File]::WriteAllLines($FilePath, $InputObject)            } else {                # However WriteAllText does not add ending newline.                [System.IO.File]::WriteAllText($FilePath, $InputObject)            }        }    }}\nfunction Import-ScoopShim {    Write-InstallInfo ‘Creating shim…’    # The scoop executable    $path &#x3D; “$SCOOP_APP_DIR\\bin\\scoop.ps1”\nif (!(Test-Path $SCOOP_SHIMS_DIR)) {\n    New-Item -Type Directory $SCOOP_SHIMS_DIR | Out-Null\n}\n\n# The scoop shim\n$shim = &quot;$SCOOP_SHIMS_DIR\\scoop&quot;\n\n# Convert to relative path\nPush-Location $SCOOP_SHIMS_DIR\n$relativePath = Resolve-Path -Relative $path\nPop-Location\n$absolutePath = Resolve-Path $path\n\n# if $path points to another drive resolve-path prepends .\\ which could break shims\n$ps1text = if ($relativePath -match &#39;^(\\.\\\\)?\\w:.*$&#39;) {\n    @(\n        &quot;# $absolutePath&quot;,\n        &quot;`$path = `&quot;$path`&quot;&quot;,\n        &quot;if (`$MyInvocation.ExpectingInput) { `$input | &amp; `$path $arg @args } else { &amp; `$path $arg @args }&quot;,\n        &quot;exit `$LASTEXITCODE&quot;\n    )\n} else {\n    @(\n        &quot;# $absolutePath&quot;,\n        &quot;`$path = Join-Path `$PSScriptRoot `&quot;$relativePath`&quot;&quot;,\n        &quot;if (`$MyInvocation.ExpectingInput) { `$input | &amp; `$path $arg @args } else { &amp; `$path $arg @args }&quot;,\n        &quot;exit `$LASTEXITCODE&quot;\n    )\n}\n$ps1text -join &quot;`r`n&quot; | Out-UTF8File &quot;$shim.ps1&quot;\n\n# make ps1 accessible from cmd.exe\n@(\n    &quot;@rem $absolutePath&quot;,\n    &#39;@echo off&#39;,\n    &#39;setlocal enabledelayedexpansion&#39;,\n    &#39;set args=%*&#39;,\n    &#39;:: replace problem characters in arguments&#39;,\n    &quot;set args=%args:`&quot;=&#39;%&quot;,\n    &quot;set args=%args:(=``(%&quot;,\n    &quot;set args=%args:)=``)%&quot;,\n    &quot;set invalid=`&quot;=&#39;&quot;,\n    &#39;if !args! == !invalid! ( set args= )&#39;,\n    &#39;where /q pwsh.exe&#39;,\n    &#39;if %errorlevel% equ 0 (&#39;,\n    &quot;    pwsh -noprofile -ex unrestricted -file `&quot;$absolutePath`&quot; $arg %args%&quot;,\n    &#39;) else (&#39;,\n    &quot;    powershell -noprofile -ex unrestricted -file `&quot;$absolutePath`&quot; $arg %args%&quot;,\n    &#39;)&#39;\n) -join &quot;`r`n&quot; | Out-UTF8File &quot;$shim.cmd&quot;\n\n@(\n    &#39;#!/bin/sh&#39;,\n    &quot;# $absolutePath&quot;,\n    &#39;if command -v pwsh.exe &gt; /dev/null 2&gt;&amp;1; then&#39;,\n    &quot;    pwsh.exe -noprofile -ex unrestricted -file `&quot;$absolutePath`&quot; $arg `&quot;$@`&quot;&quot;,\n    &#39;else&#39;,\n    &quot;    powershell.exe -noprofile -ex unrestricted -file `&quot;$absolutePath`&quot; $arg `&quot;$@`&quot;&quot;,\n    &#39;fi&#39;\n) -join &quot;`n&quot; | Out-UTF8File $shim -NoNewLine\n\n}\nfunction Get-Env {    param(        [String] $name,        [Switch] $global    )\n$RegisterKey = if ($global) {\n    Get-Item -Path &#39;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager&#39;\n} else {\n    Get-Item -Path &#39;HKCU:&#39;\n}\n\n$EnvRegisterKey = $RegisterKey.OpenSubKey(&#39;Environment&#39;)\n$RegistryValueOption = [Microsoft.Win32.RegistryValueOptions]::DoNotExpandEnvironmentNames\n$EnvRegisterKey.GetValue($name, $null, $RegistryValueOption)\n\n}\nfunction Publish-Env {    if (-not (‘Win32.NativeMethods’ -as [Type])) {        Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @’[DllImport(“user32.dll”, SetLastError &#x3D; true, CharSet &#x3D; CharSet.Auto)]public static extern IntPtr SendMessageTimeout(    IntPtr hWnd, uint Msg, UIntPtr wParam, string lParam,    uint fuFlags, uint uTimeout, out UIntPtr lpdwResult);‘@    }\n$HWND_BROADCAST = [IntPtr] 0xffff\n$WM_SETTINGCHANGE = 0x1a\n$result = [UIntPtr]::Zero\n\n[Win32.Nativemethods]::SendMessageTimeout($HWND_BROADCAST,\n    $WM_SETTINGCHANGE,\n    [UIntPtr]::Zero,\n    &#39;Environment&#39;,\n    2,\n    5000,\n    [ref] $result\n) | Out-Null\n\n}\nfunction Write-Env {    param(        [String] $name,        [String] $val,        [Switch] $global    )\n$RegisterKey = if ($global) {\n    Get-Item -Path &#39;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager&#39;\n} else {\n    Get-Item -Path &#39;HKCU:&#39;\n}\n\n$EnvRegisterKey = $RegisterKey.OpenSubKey(&#39;Environment&#39;, $true)\nif ($val -eq $null) {\n    $EnvRegisterKey.DeleteValue($name)\n} else {\n    $RegistryValueKind = if ($val.Contains(&#39;%&#39;)) {\n        [Microsoft.Win32.RegistryValueKind]::ExpandString\n    } elseif ($EnvRegisterKey.GetValue($name)) {\n        $EnvRegisterKey.GetValueKind($name)\n    } else {\n        [Microsoft.Win32.RegistryValueKind]::String\n    }\n    $EnvRegisterKey.SetValue($name, $val, $RegistryValueKind)\n}\nPublish-Env\n\n}\nfunction Add-ShimsDirToPath {    # Get $env:PATH of current user    $userEnvPath &#x3D; Get-Env ‘PATH’\nif ($userEnvPath -notmatch [Regex]::Escape($SCOOP_SHIMS_DIR)) {\n    $h = (Get-PSProvider &#39;FileSystem&#39;).Home\n    if (!$h.EndsWith(&#39;\\&#39;)) {\n        $h += &#39;\\&#39;\n    }\n\n    if (!($h -eq &#39;\\&#39;)) {\n        $friendlyPath = &quot;$SCOOP_SHIMS_DIR&quot; -Replace ([Regex]::Escape($h)), &#39;~\\&#39;\n        Write-InstallInfo &quot;Adding $friendlyPath to your path.&quot;\n    } else {\n        Write-InstallInfo &quot;Adding $SCOOP_SHIMS_DIR to your path.&quot;\n    }\n\n    # For future sessions\n    Write-Env &#39;PATH&#39; &quot;$SCOOP_SHIMS_DIR;$userEnvPath&quot;\n    # For current session\n    $env:PATH = &quot;$SCOOP_SHIMS_DIR;$env:PATH&quot;\n}\n\n}\nfunction Use-Config {    if (!(Test-Path $SCOOP_CONFIG_FILE)) {        return $null    }\ntry {\n    return (Get-Content $SCOOP_CONFIG_FILE -Raw | ConvertFrom-Json -ErrorAction Stop)\n} catch {\n    Deny-Install &quot;ERROR loading $SCOOP_CONFIG_FILE`: $($_.Exception.Message)&quot;\n}\n\n}\nfunction Add-Config {    param (        [Parameter(Mandatory &#x3D; $True, Position &#x3D; 0)]        [String] $Name,        [Parameter(Mandatory &#x3D; $True, Position &#x3D; 1)]        [String] $Value    )\n$scoopConfig = Use-Config\n\nif ($scoopConfig -is [System.Management.Automation.PSObject]) {\n    if ($Value -eq [bool]::TrueString -or $Value -eq [bool]::FalseString) {\n        $Value = [System.Convert]::ToBoolean($Value)\n    }\n    if ($null -eq $scoopConfig.$Name) {\n        $scoopConfig | Add-Member -MemberType NoteProperty -Name $Name -Value $Value\n    } else {\n        $scoopConfig.$Name = $Value\n    }\n} else {\n    $baseDir = Split-Path -Path $SCOOP_CONFIG_FILE\n    if (!(Test-Path $baseDir)) {\n        New-Item -Type Directory $baseDir | Out-Null\n    }\n\n    $scoopConfig = New-Object PSObject\n    $scoopConfig | Add-Member -MemberType NoteProperty -Name $Name -Value $Value\n}\n\nif ($null -eq $Value) {\n    $scoopConfig.PSObject.Properties.Remove($Name)\n}\n\nConvertTo-Json $scoopConfig | Set-Content $SCOOP_CONFIG_FILE -Encoding ASCII\nreturn $scoopConfig\n\n}\nfunction Add-DefaultConfig {    # If user-level SCOOP env not defined, save to root_path    if (!(Get-Env ‘SCOOP’)) {        if ($SCOOP_DIR -ne “$env:USERPROFILE\\scoop”) {            Write-Verbose “Adding config root_path: $SCOOP_DIR”            Add-Config -Name ‘root_path’ -Value $SCOOP_DIR | Out-Null        }    }\n# Use system SCOOP_GLOBAL, or set system SCOOP_GLOBAL\n# with $env:SCOOP_GLOBAL if RunAsAdmin, otherwise save to global_path\nif (!(Get-Env &#39;SCOOP_GLOBAL&#39; -global)) {\n    if ((Test-IsAdministrator) -and $env:SCOOP_GLOBAL) {\n        Write-Verbose &quot;Setting System Environment Variable SCOOP_GLOBAL: $env:SCOOP_GLOBAL&quot;\n        [Environment]::SetEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;, $env:SCOOP_GLOBAL, &#39;Machine&#39;)\n    } else {\n        if ($SCOOP_GLOBAL_DIR -ne &quot;$env:ProgramData\\scoop&quot;) {\n            Write-Verbose &quot;Adding config global_path: $SCOOP_GLOBAL_DIR&quot;\n            Add-Config -Name &#39;global_path&#39; -Value $SCOOP_GLOBAL_DIR | Out-Null\n        }\n    }\n}\n\n# Use system SCOOP_CACHE, or set system SCOOP_CACHE\n# with $env:SCOOP_CACHE if RunAsAdmin, otherwise save to cache_path\nif (!(Get-Env &#39;SCOOP_CACHE&#39; -global)) {\n    if ((Test-IsAdministrator) -and $env:SCOOP_CACHE) {\n        Write-Verbose &quot;Setting System Environment Variable SCOOP_CACHE: $env:SCOOP_CACHE&quot;\n        [Environment]::SetEnvironmentVariable(&#39;SCOOP_CACHE&#39;, $env:SCOOP_CACHE, &#39;Machine&#39;)\n    } else {\n        if ($SCOOP_CACHE_DIR -ne &quot;$SCOOP_DIR\\cache&quot;) {\n            Write-Verbose &quot;Adding config cache_path: $SCOOP_CACHE_DIR&quot;\n            Add-Config -Name &#39;cache_path&#39; -Value $SCOOP_CACHE_DIR | Out-Null\n        }\n    }\n}\n\n# save current datatime to last_update\nAdd-Config -Name &#39;last_update&#39; -Value ([System.DateTime]::Now.ToString(&#39;o&#39;)) | Out-Null\n\n}\nfunction Test-CommandAvailable {    param (        [Parameter(Mandatory &#x3D; $True, Position &#x3D; 0)]        [String] $Command    )    return [Boolean](Get-Command $Command -ErrorAction SilentlyContinue)}\nfunction Install-Scoop {    Write-InstallInfo ‘Initializing…’    # Validate install parameters    Test-ValidateParameter    # Check prerequisites    Test-Prerequisite    # Enable TLS 1.2    Optimize-SecurityProtocol\n# Download scoop from GitHub\nWrite-InstallInfo &#39;Downloading...&#39;\n$downloader = Get-Downloader\n[bool]$downloadZipsRequired = $True\n\nif (Test-CommandAvailable(&#39;git&#39;)) {\n    $old_https = $env:HTTPS_PROXY\n    $old_http = $env:HTTP_PROXY\n    try {\n        if ($downloader.Proxy) {\n            #define env vars for git when behind a proxy\n            $Env:HTTP_PROXY = $downloader.Proxy.Address\n            $Env:HTTPS_PROXY = $downloader.Proxy.Address\n        }\n        Write-Verbose &quot;Cloning $SCOOP_PACKAGE_GIT_REPO to $SCOOP_APP_DIR&quot;\n        git clone -q $SCOOP_PACKAGE_GIT_REPO $SCOOP_APP_DIR\n        if (-Not $?) {\n            throw &#39;Cloning failed. Falling back to downloading zip files.&#39;\n        }\n        Write-Verbose &quot;Cloning $SCOOP_MAIN_BUCKET_GIT_REPO to $SCOOP_MAIN_BUCKET_DIR&quot;\n        git clone -q $SCOOP_MAIN_BUCKET_GIT_REPO $SCOOP_MAIN_BUCKET_DIR\n        if (-Not $?) {\n            throw &#39;Cloning failed. Falling back to downloading zip files.&#39;\n        }\n        $downloadZipsRequired = $False\n    } catch {\n        Write-Warning &quot;$($_.Exception.Message)&quot;\n        $Global:LastExitCode = 0\n    } finally {\n        $env:HTTPS_PROXY = $old_https\n        $env:HTTP_PROXY = $old_http\n    }\n}\n\nif ($downloadZipsRequired) {\n    # 1. download scoop\n    $scoopZipfile = &quot;$SCOOP_APP_DIR\\scoop.zip&quot;\n    if (!(Test-Path $SCOOP_APP_DIR)) {\n        New-Item -Type Directory $SCOOP_APP_DIR | Out-Null\n    }\n    Write-Verbose &quot;Downloading $SCOOP_PACKAGE_REPO to $scoopZipfile&quot;\n    $downloader.downloadFile($SCOOP_PACKAGE_REPO, $scoopZipfile)\n    # 2. download scoop main bucket\n    $scoopMainZipfile = &quot;$SCOOP_MAIN_BUCKET_DIR\\scoop-main.zip&quot;\n    if (!(Test-Path $SCOOP_MAIN_BUCKET_DIR)) {\n        New-Item -Type Directory $SCOOP_MAIN_BUCKET_DIR | Out-Null\n    }\n    Write-Verbose &quot;Downloading $SCOOP_MAIN_BUCKET_REPO to $scoopMainZipfile&quot;\n    $downloader.downloadFile($SCOOP_MAIN_BUCKET_REPO, $scoopMainZipfile)\n\n    # Extract files from downloaded zip\n    Write-InstallInfo &#39;Extracting...&#39;\n    # 1. extract scoop\n    $scoopUnzipTempDir = &quot;$SCOOP_APP_DIR\\_tmp&quot;\n    Write-Verbose &quot;Extracting $scoopZipfile to $scoopUnzipTempDir&quot;\n    Expand-ZipArchive $scoopZipfile $scoopUnzipTempDir\n    Copy-Item &quot;$scoopUnzipTempDir\\scoop-*\\*&quot; $SCOOP_APP_DIR -Recurse -Force\n    # 2. extract scoop main bucket\n    $scoopMainUnzipTempDir = &quot;$SCOOP_MAIN_BUCKET_DIR\\_tmp&quot;\n    Write-Verbose &quot;Extracting $scoopMainZipfile to $scoopMainUnzipTempDir&quot;\n    Expand-ZipArchive $scoopMainZipfile $scoopMainUnzipTempDir\n    Copy-Item &quot;$scoopMainUnzipTempDir\\Main-*\\*&quot; $SCOOP_MAIN_BUCKET_DIR -Recurse -Force\n\n    # Cleanup\n    Remove-Item $scoopUnzipTempDir -Recurse -Force\n    Remove-Item $scoopZipfile\n    Remove-Item $scoopMainUnzipTempDir -Recurse -Force\n    Remove-Item $scoopMainZipfile\n}\n# Create the scoop shim\nImport-ScoopShim\n# Finially ensure scoop shims is in the PATH\nAdd-ShimsDirToPath\n# Setup initial configuration of Scoop\nAdd-DefaultConfig\n\nWrite-InstallInfo &#39;Scoop was installed successfully!&#39; -ForegroundColor DarkGreen\nWrite-InstallInfo &quot;Type &#39;scoop help&#39; for instructions.&quot;\n\n}\nfunction Write-DebugInfo {    param($BoundArgs)\nWrite-Verbose &#39;-------- PSBoundParameters --------&#39;\n$BoundArgs.GetEnumerator() | ForEach-Object { Write-Verbose $_ }\nWrite-Verbose &#39;-------- Environment Variables --------&#39;\nWrite-Verbose &quot;`$env:USERPROFILE: $env:USERPROFILE&quot;\nWrite-Verbose &quot;`$env:ProgramData: $env:ProgramData&quot;\nWrite-Verbose &quot;`$env:SCOOP: $env:SCOOP&quot;\nWrite-Verbose &quot;`$env:SCOOP_CACHE: $SCOOP_CACHE&quot;\nWrite-Verbose &quot;`$env:SCOOP_GLOBAL: $env:SCOOP_GLOBAL&quot;\nWrite-Verbose &#39;-------- Selected Variables --------&#39;\nWrite-Verbose &quot;SCOOP_DIR: $SCOOP_DIR&quot;\nWrite-Verbose &quot;SCOOP_CACHE_DIR: $SCOOP_CACHE_DIR&quot;\nWrite-Verbose &quot;SCOOP_GLOBAL_DIR: $SCOOP_GLOBAL_DIR&quot;\nWrite-Verbose &quot;SCOOP_CONFIG_HOME: $SCOOP_CONFIG_HOME&quot;\n\n}\nPrepare variables$IS_EXECUTED_FROM_IEX &#x3D; ($null -eq $MyInvocation.MyCommand.Path)\nAbort when the language mode is restrictedTest-LanguageMode\nScoop root directory$SCOOP_DIR &#x3D; $ScoopDir, $env:SCOOP, “$env:USERPROFILE\\scoop” | Where-Object { -not [String]::IsNullOrEmpty($_) } | Select-Object -First 1\nScoop global apps directory$SCOOP_GLOBAL_DIR &#x3D; $ScoopGlobalDir, $env:SCOOP_GLOBAL, “$env:ProgramData\\scoop” | Where-Object { -not [String]::IsNullOrEmpty($_) } | Select-Object -First 1\nScoop cache directory$SCOOP_CACHE_DIR &#x3D; $ScoopCacheDir, $env:SCOOP_CACHE, “$SCOOP_DIR\\cache” | Where-Object { -not [String]::IsNullOrEmpty($_) } | Select-Object -First 1\nScoop shims directory$SCOOP_SHIMS_DIR &#x3D; “$SCOOP_DIR\\shims”\nScoop itself directory$SCOOP_APP_DIR &#x3D; “$SCOOP_DIR\\apps\\scoop\\current”\nScoop main bucket directory$SCOOP_MAIN_BUCKET_DIR &#x3D; “$SCOOP_DIR\\buckets\\main”\nScoop config file location$SCOOP_CONFIG_HOME &#x3D; $env:XDG_CONFIG_HOME, “$env:USERPROFILE.config” | Select-Object -First 1$SCOOP_CONFIG_FILE &#x3D; “$SCOOP_CONFIG_HOME\\scoop\\config.json”\nTODO: Use a specific version of Scoop and the main bucket$SCOOP_PACKAGE_REPO &#x3D; ‘https://github.com/ScoopInstaller/Scoop/archive/master.zip‘$SCOOP_MAIN_BUCKET_REPO &#x3D; ‘https://github.com/ScoopInstaller/Main/archive/master.zip‘\n$SCOOP_PACKAGE_GIT_REPO &#x3D; ‘https://github.com/ScoopInstaller/Scoop.git‘$SCOOP_MAIN_BUCKET_GIT_REPO &#x3D; ‘https://github.com/ScoopInstaller/Main.git‘\nQuit if anything goes wrong$oldErrorActionPreference &#x3D; $ErrorActionPreference$ErrorActionPreference &#x3D; ‘Stop’\nLogging debug infoWrite-DebugInfo $PSBoundParameters\nBootstrap functionInstall-Scoop\nReset $ErrorActionPreference to original value$ErrorActionPreference &#x3D; $oldErrorActionPreference\n\n\n","categories":["article"],"tags":["default"]},{"title":".bashrc改不改","url":"/posts/7a37d6c9/","content":".bashrc干什么我们谈论的是Linux系统。Unix类系统也可以参考，但Windows系统就别看了。\n如果我们用ls -a命令查看用户主目录下的文件，我们可以发现有4个带”bash”的文件：\n\n.bashrc：非登录Session初始化时执行的配置。\n.bash_profile：登录Session初始化时执行的配置。\n.bash_logout：退出bash shell时运行的脚本。可能为空，也可能有一些内容。\n.bash_history：bash输入命令的历史记录。\n\n登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。\n而非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行bash命令，就会新建一个非登录 Session。\n当然，这里我说的都只是用户的配置文件，在加载用户的配置文件之间会先加载系统的配置文件。更详细的知识见阮一峰Bash脚本教程。如果画一个简单的图，就是这样：\n%%&#123; init: &#123; 'flowchart': &#123; 'curve': 'basis' &#125; &#125; &#125;%%\nflowchart TB\n    classDef main fill:#f96\n    a[登录类Session]-->b[\"/etc/profile\"]\n    b-->|最后运行|e[\"~/.bash_profile\"]\n\nsubgraph ide2 [用户层面]\n    e-->f(\"~/.bashrc\")\nend\n    subgraph ide1 [系统层面]\n    direction BT\n    b-->|先运行|c[\"/etc/bash.bashrc\"]\n    b-->|后运行|d[(\"/etc/profile.d目录下所有文件\")]\n    end\n        style ide2 fill:#f0e518, font-size:12\n\n\n\n\n%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%\nflowchart TB\nclassDef main fill:#f96\na[登录类Session]-->b[\"/etc/profile\"]\nb-->|最后运行|e[\"~/.bash_profile\"]\n\nsubgraph ide2 [用户层面]\ne-->f(\"~/.bashrc\")\nend\nsubgraph ide1 [系统层面]\ndirection BT\nb-->|先运行|c[\"/etc/bash.bashrc\"]\nb-->|后运行|d[(\"/etc/profile.d目录下所有文件\")]\nend\nstyle ide2 fill:#f0e518, font-size:12\n\n\n\n该不该直接改.bashrc如果要加环境变量，网上一般是让改.bashrc。为什么？因为在.bash_profile里一般是引用了.bashrc的。\n# .bash_profile\n\n# Get the aliases and functions\nif [ -f  ~/.bashrc ]; then\n    . ~/.bashrc\nfi\n\n# User specific environment and startup programs\n\nPTAH=\"$PATH:$HOME/.local/bin:$HOME/bin\"\n\nexport PATH\n\n这也就带来了一个问题，如果直接改.bashrc，一旦改出了一些严重的问题，就可能导致无法登录的情况。所以不推荐直接改.bashrc\n那么，有没有安全一点的方法？\n更安全的方法当然有，只不过可能有点麻烦。\n\n\n不去修改.bashrc，而是把你需要的环境变量什么的写到一个新的文件里。每次需要运行的时候，source你新写的那个文件。\n比如我需要加一些环境变量。那么我把环境变量写到一个叫作.mybashrc的全新的文件里。然后每次我登录的时候，就执行：\nsource .mybashrc\n\n最安全，因为根本没有改.bashrc、.bash_profile。而且如果你改的环境变量有问题，退出之后重新登录就好了。\n只不过有点麻烦，因为每次登录都需要source一下。\n鱼和熊掌不可兼得，要安全只能牺牲方便。\n牺牲一小点安全的折中方法注：做下面的操作时一定要写对\n有一个折中的方法，就是在.bash_profile里加入判断逻辑，每次登录时选择一下是否运行.bashrc。比如在.bash_profile末尾加入这些指令：\nread -t 10 -p \"10秒倒计时，是否载入.bashrc? [Y/n]: \" var\nvar=$&#123;var:-\"yes\"&#125;\nif [[ $&#123;var,,&#125; == \"yes\" || $&#123;var,,&#125; == \"y\" ]]; then\n    echo -e \"载入中\"\n    source ~/.bashrc\nelse\n    echo -e \"取消载入\"\nfi\n\n这样如果出问题，就有更改的余地。\ntmux默认开启的是登录shell (login shell) ，可以通过在.tmux.conf文件里加入这条设置来改变：\nset -g default-command bash\n\n# 或者这条：\nset-option -g default-shell bash\n\n（但你这不是需要改.bash_profile文件吗？\n（所以这段只针对有一定能力的人\n一些杂谈bashrc中的rc是什么含义？\n","categories":["article"],"tags":["linux","bash"]},{"title":"c语言中fork,exec和system函数的理解","url":"/posts/321f/","content":"fork用于创建子进程。\n由fork创建的新进程被称为子进程（child process）。fork函数被调用一次，但返回两次。\n\n在父进程中，fork返回新创建子进程的进程ID。\n在子进程中，fork返回0。\n如果出现错误，fork返回一个负值。\n\n包含在&lt;unistd.h&gt;中，是Unix系统特有的文件(Mac os并不太清楚)，因此需要用gnu标准进行编译。\nfork的作用是创建一个子进程。网上有不少博客，但其中有相当一部分并没有点明fork之后会怎么样。实验证明：fork之后的子进程不是重新运行整个程序，而是从fork处接着向后运行。比如下面的程序：\n#include &lt;stdio.h>\n#include &lt;unistd.h>\n#include &lt;string.h>\nint main(int argc, char *argv[])\n&#123;\n    int sum=0,i;\n    char cmd[1023][20], ch;\n    int cnt=1, status;\n    printf(\"before fork\\n\");\n    while(cnt&lt;=2) &#123;\n            pid_t id=fork();\n            printf(\"father: id=%d, cnt=%d\\n\",id,cnt);\n            if (id == 0) &#123;\n                printf(\"\\e[33mSon\\e[0m\\n\");\n            &#125;\n        cnt++;\n    &#125;\n    printf(\"\\e[31mafter fork\\e[0m\\n\");\n    // printf(\"finally: id=%d\\n\",id);\n    return 0;\n&#125;\n\n其结果应该如下：(父进程和子进程之间没有固定的先后顺序，看运气)\n如果画个进程运行图，应该是这样：\n\n\n\nflowchart LR\nclassDef main fill:#f96\nclassDef sub1 fill:#56b800\nclassDef sub2 fill:#7abceb\nclassDef sub3 fill:#ebe01a\nroot(root):::main-->a(fork)\na:::main-->c((dad)):::main\nc-->d(fork):::main\nd-->e((dad)):::main\na-->b((son)):::sub1\nd-->f((son)):::sub2\nb-->g(fork):::sub1\ng-->h((subdad)):::sub1\ng-->i((son)):::sub3\n\n\n\n流程如下：\n\n程序从main进入，此时的身份我们假设为root。\n当运行到fork时，产生一个子进程sub1(此时cnt=1)。两个进程都向后运行。父进程无其它输出，子进程输出Son\nroot和sub1都进入下一轮循环，此时cnt=2。这意味着root和sub1都会进行一次fork，分别产生sub2和sub3。\n\n","tags":["C","linux"]},{"title":"git中的后悔药","url":"/posts/8804f53c/","content":"版本库中的后悔药git commit –amendgit revert id回到第id次提交，但是是用提交一个新的分支的方式\ngit reset idgit reset id 命令会直接删除版本库中的一次commit，id是你想要回到的那个版本。其有3个参数可选：\n\n--soft：将你删除的这次commit在版本库中的文件放到工作区和暂存区\n--mixed（默认）：将你删除的这次commit在版本库中的文件放仅到工作区\n--hard（危险）：直接删除，在提交id之后的所有修改永远丢失！\n\n如果第一次提交的时候，没有在gitignore文件中添加忽略文件，那么这些文件（目录也是文件）就会被git跟踪。此时如果想让git取消对一些文件的跟踪，可以用如下命令：\ngit rm (-r) --cached xxx        //仅删除在暂存区中的已跟踪文件\n删除后，本地的文件还在，但git没有再跟踪了。之后再去修改.gitignore就可以了。\n最好.gitignore文件的修改单独做一次提交\n","categories":["article"],"tags":["Git"]},{"title":"linux下常见的环境变量对应的目录","url":"/posts/1df8ddf2/","content":"环境变量作用\n\n\n环境变量\n作用\n\n\n\nACLOCAL\n在GNU automake套件中起作用。对应各个软件里的share/aclocal目录\n\n\nPATH\n可执行程序的目录。\n\n\nPKG_CONFIG_PATH\n作用见后文，对应软件里的lib/pkgconfig或share/pkgconfig目录\n\n\nLD_LIBRARY_PATH\n主要是用于指定动态链接器（ld）查找ELF可执行文件运行时所依赖的动态库（so）的路径。即用于在程序运行期间查找动态链接库时，指定除了系统默认路径(&#x2F;usr&#x2F;lib)之外的路径。对应lib目录\n\n\nLIBRARY_PATH\n在程序编译期间查找动态链接库时指定的查找共享库的路径。指定gcc编译需要链接动态链接库的目录。\n\n\nCPATH\nCPATH 环境变量用于 C&#x2F;C++ 预处理，它列出了预处理器检索 C&#x2F;C++ 头文件的目录，与之相对的环境变量还有 C_INCLUDE_PATH、CPLUS_INCLUDE_PATH 和 OBJC_INCLUDE_PATH。其中无论预处理哪种语言，都会使用 CPATH 环境变量，而其余的三种环境变量仅在预处理指定的语言时才会适用。\n\n\n以下部分来自于https://blog.csdn.net/qq_36182852/article/details/109680418\n\nPKG-CONFIG用来检索系统中安装库文件的信息。典型的是用作库的编译和连接。一般来说，如果库的头文件不在&#x2F;usr&#x2F;include目录中，那么在编译的时候需要用-I参数指定其路径。由于同一个库在不同系统上可能位于不同的目录下，用户安装库的时候也可以将库安装在不同的目录下，所以即使使用同一个库，由于库的路径的不同，造成了用-I参数指定的头文件的路径和在连接时使用-L参数指定lib库的路径都可能不同，其结果就是造成了编译命令界面的不统一。可能由于编译，连接的不一致，造成同一份程序从一台机器copy到另一台机器时就可能会出现问题。\nPKG-CONFIG就是用来解决编译连接界面不统一问题的一个工具。它的基本思想：PKG-CONFIG是通过库提供的一个.pc文件获得库的各种必要信息，包括版本信息、编译和连接需要的参数等。需要的时候可以通过pkg-config提供的参数(–cflags, –libs)，将所需信息提取出来供编译和连接使用。这样，不管库文件安装在哪，通过库对应的.pc文件就可以准确定位，可以使用相同的编译和连接命令，使得编译和连接界面统一。\n它提供的主要功能有:\n\n检查库的版本号。如果所需库的版本不满足要求，打印出错误信息，避免连接错误版本的库文件。\n获得编译预处理参数，如宏定义，头文件的路径。\n获得编译参数，如库及其依赖的其他库的位置，文件名及其他一些连接参数。\n自动加入所依赖的其他库的设置。\n\n\n参考文献\n【Linux】PKG_CONFIG_PATH: https://blog.csdn.net/qq_36182852&#x2F;article&#x2F;details&#x2F;109680418\nLinux 环境变量 PATH、CPATH、LIBRARY_PATH和LD_LIBRARY_PATH\n\n","categories":["article"],"tags":["linux","tips"]},{"title":"『码图』而非『画图』——Mermaid语法简介","url":"/posts/8233ee46/","content":"相信对于程序员来说，markdown这一个词应该不陌生。markdown的语法很简单，但简单的语法也可以扩展出许多高级的方法。本文就是来介绍其中一个高级用法——mermaid\n什么是mermaid？mermaid是一个方便（相对于经常敲代码的人(✿◠‿◠)）的绘制流程图的js工具。严格来说，mermaid并不是markdown自带的语法。但目前多数markdown(严格来说应该是markdown-mmd)都支持mermaid。\nmermaid可以支持如下种类的图(2024-03-06)\n\n流程图(flowchart)\n序列图(sequenceDiagram)\n类图(classDiagram)\n状态图(stateDiagram-v2)\n实体关系图(erDiagram)\n甘特图(gantt)\n用户旅程图(journey)\nGit图(gitGraph)\n饼图(pie)\n简单版的思维导图(mindmap)\n四象限图(quadrantChart)\n柱状图(xychart-beta)\n框图(block-beta)\n\n这里是在线的mermaid编辑器\n既然文章的题目叫简介，那么肯定讲得不如官方文档详细。我只是记录一些基本的语法，以及我遇到的问题\n流程图","categories":["article"],"tags":["程序语言","markdown"]},{"title":"从源码安装openFOAM","url":"/posts/65f85108/","content":"系统环境CentOS 7，无网络连接，无sudo权限\n参考了官方网站的安装指南\n第1步，安装依赖\n\n\n依赖包\n版本\n如何获取\n\n\n\ngcc\n&gt;&#x3D;5.4\nmodule load gnu\n\n\ncmake\n3.28.4\n\n\n\nFLEX\n2.6.4\n从github上下载，或点击直接下载\n\n\nQT\n5.12.2\n官方镜像站，或点击直接下载\n\n\nGit\n1.8.3.1\n系统已自带\n\n\nOpenMPI\n5.0.2\n官方下载，或点击直接下载\n\n\n安装FLEX-废弃tar -zxvf flex-2.6.4.tar.gz\ncd flex-2.6.4\ninstall_to=\"需要安装到的绝对路径\"\n./configure --prefix=$&#123;install_to&#125;\nmake check\nmake install\n\nexport PATH=$&#123;install_to&#125;/bin:$&#123;PATH&#125;\nexport LD_LIBRARY_PATH=$&#123;install_to&#125;/lib:$&#123;LD_LIBRARY_PATH&#125;\nexport LIBRARY_PATH=$&#123;install_to&#125;/lib:$&#123;LIBRARY_PATH&#125;\nexport CPATH=$&#123;install_to&#125;/include:$&#123;CPATH&#125;\n\n第2步，下载源码git clone https://githubfast.com/OpenFOAM/OpenFOAM-11.git\ngit clone https://githubfast.com/OpenFOAM/ThirdParty-11.git\n\n官网上给的教程中，安装位置默认在~/OpenFOAM/下面，并且源码也在此目录中。如果需要更改安装路径，就需要更改FOAM_INIT_DIR变量的值\n正在核实中。\n","categories":["教程"],"tags":["linux","tips","openFOAM"]},{"title":"css-demo","url":"/posts/a52726e1/","content":"[toc]\n一级标题二级标题三级标题在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型通过构造模型分量来表达电离层异常。\n在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型通过构造模型分量来表达电离层异常。\n\n在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型一般通过构造模型分量来表达电离层异常。\n\n\n            在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型通过构造模型分量来表达电离层异常。\n          \n\n\n            在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型通过构造模型分量来表达电离层异常。\n          \n\n\n            在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型通过构造模型分量来表达电离层异常。\n          \n\n\n            在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型通过构造模型分量来表达电离层异常。\n          \n\n\n            在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型通过构造模型分量来表达电离层异常。\n          \n\n\n            在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型通过构造模型分量来表达电离层异常。\n          \n\n\n            在全球总电子含量（Total Electron Content, TEC）经验模型中表达各种电离层异常是一项具有挑战性的研究。现有的经验模型通过构造模型分量来表达电离层异常。\n          \n\n\n\n\n如有问题请查询百度，相关数据在https://www.baidu.com下载。\nsdfaasdfasfasfdasfasasfdasfafasfasfasfsadsdfasdfasdfasfasdfdfafasfasdfasasfadfasdfasfasafasdfasdfasdasfasdfasasdfasfafaasdfafafsa\n默认标签、红色标签、黄色标签、绿色标签、蓝色标签、灰色标签、自定义颜色标签\n标签标签\n下划线、着重号、波浪线、删除线、阴影效果、空心字、字体闪烁\n&#x3D;&#x3D;高亮&#x3D;&#x3D;、Enter、高亮2\n\n            xxx\n\n          \n\n\n    折叠标签\n    青青子衿，悠悠我心\n    老骥伏枥，志在千里\n\n\n\n                证明：    青青子衿，悠悠我心    老骥伏枥，志在千里\t\tsdfadaf\tasfasdfa\tasdfasd\t\t$$\\varphi\t\t\t$$上面有一条分界线\n          \n\n\n这里有一个脚注[1]。\n行内公式：$y&#x3D;ax^2+bx+c$\n行间公式：$$y&#x3D;ax^2+bx+c$$\n行间公式：$$ \\begin{gather*}\\begin{aligned}左边 &amp;&#x3D; \\mathbf{ \\dot{r} } \\cdot \\frac{\\mathrm{d}(\\mathbf{ \\dot{r} })}{\\mathrm{d}t}&#x3D; \\frac{\\mathrm{d}}{\\mathrm{d}t}\\int_{}^{} \\mathbf{ \\dot{r} }\\cdot \\frac{\\mathrm{d}(\\mathbf{ \\dot{r} })}{\\mathrm{d}t}\\mathrm{d}t\\&amp;&#x3D; \\frac12 \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\mathbf{ \\dot{r} }\\cdot \\mathbf{ \\dot{r} }\\right)\\&amp;&#x3D; \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\frac12 v^2\\right)\\quad (此处v是大小)\\end{aligned}\\end{gather*} $$\nprint(&#39;Hello World&#39;)\na = int(input(newlife))\nclear;clc;\n\n% 加载数据\nx = 1:100;\ny = linspace(10,40,100) + 10*rand(1,100);\n\n% 计算拟合曲线\np = polyfit(x,y,1);\na = p(1);\nb = p(2);\nx0 = [0,100];\ny0 = [a*x0(1)+b,a*x0(2)+b];\n\n% 计算相关系数\nR = corrcoef(x,y);\nR = sprintf('%.2f',R(1,2));\n\n\n有序列表\n有序列表\n有序列表\n\n\n\n\n无序列表\n\n无序列表\n无序列表\n\n\n \n事项1\n\n \n事项2\n\n \n事项3\n\n\n特殊写法的checkbox： &#123;% cb xxx, true, %&#125;\n\n            xxx\n\n          \n\n\n\n\n\n\n\n\n\n日期\n金额\n利息\n\n\n\n2012.03\n￥2000\n￥2000\n\n\n2012.04\n￥2000\n￥2000\n\n\n2012.05\n￥2000\n￥2000\n\n\n2012.06\n￥2000\n￥2000\n\n\n\n表1.三线表\n\n\n  \n    日期\n    金额\n    利息\n  \n  \n    2012.01\n    ￥2000\n    ￥2000\n  \n  \n    2012.02\n    ￥2000\n    ￥2000\n  \n      \n    2012.03\n    ￥2000\n    ￥2000\n  \n\n\n \n\n\n\n\n\n相关参考张亭,赵庆鑫,钟慧鑫,张一彬,朱云聪,冯建迪.国际参考电离层2016模型在陆海区域的精度分析J.测绘科学,2021,46(09):14-33.DOI:10.16251&#x2F;j.cnki.1009-2307.2021.09.003.\n ↩","categories":["其它"],"tags":["effect-testing"]},{"title":"syncthing/SyncTrayzor如何同步而不删除","url":"/posts/d97a10f4/","content":"head2\n之间在用syncthing同步笔记的时候，总是担心一个设备的文件被删除后所有的设备一同删除。结果，真的发生了。好在通过一些手段，把数据找回来了。\n在网上找了很久，终于找到了解决方法。下面出图文教程\n\n\n（感谢这篇博客的介绍）\n操作-&gt;高级\n\n\n\n\n选中你要同步的文件夹，然后 把 IgnoreDelete 的勾打上。\n\n\n\n\n\n\n\n\n","tags":["syncthing","synctrayzor","增量同步"]},{"title":"从源码安装Tmux","url":"/posts/5d529438/","content":"1. 相关环境\n系统：CentOS 7.6 (无网，无sudo)\ntmux：3.5\nncurses：6.2\nlibevent：2.1.2-stable\n\n2. 安装2.1 安装libevent在我安装的服务器上并没有libevent，需要手动进行安装。\n下载libevent-2.1.12-stable.tar.gz，解压之后进行目录，正常地用configure安装：\ntar -zxvf libevent-2.1.12-stable.tar.gz\ncd libevent-2.1.12-stable\n./configure --prefix=\"$&#123;program&#125;/libevent\"\nmake -j # 不带具体的数字，会自动达到最大数\nmake install\n\n安装完成后，相当重要的一点在于设置环境变量，这是手动安装软件所带来的麻烦之处。\nexport LD_LIBRARY_PATH=\"$&#123;program&#125;/libevent/lib:$LD_LIBRARY_PATH\"\nexport PKG_CONFIG_PATH=\"$&#123;program&#125;/libevent/lib/pkgconfig:$PKG_CONFIG_PATH\"\n\n2.2 安装ncurses服务器比较老，连ncurses也没有安装，需要我们手动装一下。\n下载ncurses-6.2.tar.gz，解压之后进行目录，正常地用configure安装：\ntar -zxvf ncurses-6.2.tar.gz\ncd ncurses-6.2\n./configure --prefix=\"$&#123;program&#125;/ncurses\"\nmake -j # 不带具体的数字，会自动达到最大数\nmake install\n\nncurses如果手动安装，不会产生pkgconfig，需要我们自己手写ncurses.pc。\n如下为手写的ncurses.pc： 路径需要用绝对路径\nName: ncurses\nDescription:ncurses\nVersion: 6.2\nCflags:-I&#x2F;your-path-to-ncurses&#x2F;include&#x2F;ncurses -I&#x2F;your-path-to-ncurses&#x2F;include\nLibs:-L&#x2F;your-path-to-ncurses&#x2F;lib -lncurses -lncurses++\n\n\n此后，需要把ncurses.pc加入环境变量PKG_CONFIG_PATH中。\n2.3 安装tmux此后就可以正常安装tmux了。\n","categories":["教程"],"tags":["linux","instruction","tmux"]},{"title":"STL-队列，栈，堆","url":"/posts/dac9b442/","content":"【C++学习笔记】：priority_queue容器 - 知乎\nSTL - emplace 与 push 的区别_优先级队列的emplace和push函数的却别-CSDN博客\n","categories":["C++ 语法"],"tags":["STL","语法","未完"]},{"title":"偏微分方程02_方程的导出，化简与分类","url":"/posts/926ecd88/","content":"1 波动方程2 热传导方程3 位势方程4 二元二阶线性方程的化简与分类分析思路二元二阶线性方程的基本形式如下：（其中 $a, b, c$ 不同时为0）\n$$a(x,y)u_{xx}+ 2b(x,y)u_{xy} + c(x,y)u_{yy} +d(x,y) u_x+e(x,y)u_y+f(x,y)u &#x3D; g(x,y)\\tag{2.4.1}$$\n为了对这个方程进行化简，我们对自变量进行局部变换。\n\n\nQ: 为什么进行变换？A: 目的是通过变换，把二阶导的系数化简，消除 1 到 2 个二阶项，最好把二阶项全部消掉。\nQ: 为什么可以变换？A: 利用隐函数存在定理。Q: 为什么对自变量进行变换？A: 当然也可以做其它的变换，只不过讲的是以书上的方法为主。\n\n\n\n隐函数存在定理^ref1：\n\n一元：$\\frac{\\partial y}{\\partial x} \\ne 0\\Longrightarrow x &#x3D;x(y)$ 存在（只有充分性）。\n二元：Jacobi 矩阵 $\\ne 0$ ，即：$$\\begin{gather}\\begin{bmatrix}\\frac{\\partial f_1}{\\partial x} &amp;\\frac{\\partial f_1}{\\partial y} \\\\frac{\\partial f_2}{\\partial x} &amp;\\frac{\\partial f_2}{\\partial y}\\end{bmatrix} \\ne 0\\end{gather}\n$$\n\n\n\n\n在 $(x_0, y_0)$ 附近利用 $\\xi &#x3D; \\xi(x,y), \\eta &#x3D; \\eta(x,y)$ 可以把式 $\\mathrm{(2.4.1)}$ 写成以 $\\xi, \\eta$ 为自变量的方程：$$AU_{\\xi\\xi} + 2BU_{\\xi\\eta} + CU_{\\eta\\eta} + DU_{\\xi} + EU_{\\eta}+FU &#x3D; G \\tag{2.4.4}$$\n主要矛盾在二阶项，所以我们暂时只关注二阶项的系数。把 $A,B,C$ 展开：$$\\begin{gather}\\large\\begin{cases}\\displaylines A(\\xi, \\eta) &#x3D; (a\\xi_x^2 + 2b\\xi_x\\xi_y + c\\xi_y^2)\\big\\vert_{x &#x3D; x(\\xi, \\eta), y &#x3D; y(\\xi, \\eta)}\\\\displaylines B(\\xi, \\eta) &#x3D; (a\\xi_x\\eta_x + b(\\xi_x\\eta_y+\\xi_y\\eta_x) + c\\xi_y\\eta_y) \\\\displaylines C(\\xi, \\eta) &#x3D; (a\\eta_x^2 + 2b\\eta_x\\eta_y + c\\eta_y^2)\\big\\vert_{x &#x3D; x(\\xi, \\eta), y &#x3D; y(\\xi, \\eta)}\\\\end{cases}\\tag{2.4.5}\\end{gather}$$我们自然希望 $A &#x3D; B &#x3D; C &#x3D; 0$ 。但我们可以证明，A,B,C 不能同时为 0。\n\n证明（思路）：\n把式 $\\mathrm{(2.4.5)}$ 看成关于 a, b, c 的参数方程，可以写出系数矩阵。如果 $A &#x3D; B &#x3D; C &#x3D; 0$ ，则方程组的解 (a, b, c) 也都为 0。这样的话与前提的假设矛盾。\n\n既然不能 3 个都为 0 ，那么可不可以让其中 1 个或 2 个为 0 ？观察可以发现，$A(\\xi, \\eta)$ 和 $C(\\xi,\\eta)$ 的形式相似，因此我们可以想办法试试让 $A &#x3D; C &#x3D; 0$。\n现在我们的目标就变成了：让 $A &#x3D; C &#x3D; 0$ 。\n为了达到分析一个方程，解 A,C 两个方程，我们先把 A, C 的表达式改一下。\n$$a\\varphi^2_x + 2b\\varphi_x\\varphi_y + c\\varphi_y^2 &#x3D; 0 \\tag{2.4.7}$$\n\n对于式 $\\mathrm{(2.4.7)}$， 如果它有2个解，并且其Jacobi行列式 $$\\left\\vert\\frac{\\partial (\\varphi_1, \\varphi_2)}{\\partial (x, y)}\\right\\vert \\ne 0$$（可逆变换），则就可以实现我们想要的目标了。\n现在问题转换为：方程 $\\mathrm{(2.4.7)}$ 的解的判断。\n这个问题，可以用下面的命题回答：\n\n            命题若 $\\varphi(x,y) &#x3D; C$ （常数）是一阶常微分方程：$$a\\mathrm{d}y^2 -2b \\mathrm{d}y\\mathrm{d}x+c\\mathrm{d}x^2 &#x3D; 0 \\tag{2.4.8}$$的隐式解，且 $\\varphi_x, \\varphi_y$ 不同时为 0 ($\\varphi_x^2+\\varphi_y^2 \\ne 0$)，则 $\\varphi(x, y)$ 是方程 $\\mathrm{(2.4.7)}$ 的解。\n          \n\n\n证明思路：对 $\\varphi_x^2 + \\varphi_y^2 &#x3D; 0$ 两边求 $\\varphi_x$ 的导，得：$$\\begin{gather}2\\varphi_x + 2\\varphi_y\\frac{\\varphi_y}{\\varphi_x} &#x3D; 0\\\\varphi_x + \\varphi_y\\frac{\\mathrm{d}y}{\\mathrm{d}x} &#x3D; 0\\\\therefore \\frac{\\mathrm{d}y}{\\mathrm{d}x} &#x3D; -\\frac{\\varphi_x}{\\varphi_y}\\end{gather}$$\n代回式 $\\mathrm{(2.4.8)}$，则可以得到式 $\\mathrm{(2.4.7)}$ 的格式。 \n\n这里的式 $\\mathrm{(2.4.8)}$称为式 $\\mathrm{(2.4.1)}$ 的特征方程。\n于是，现在的目的成了：求解式 $\\mathrm{(2.4.8)}$。\n\n如果 $a(x_0, y_0) &#x3D; c(x_0, y_0) &#x3D; 0$ (这里 a, c 的含义与式 $\\mathrm{(2.4.1)}$ 的含义相同)，则式 $\\mathrm{(2.4.1)}$ 不用化简。\n如果 $a(x_0, y_0) , c(x_0, y_0)$ 中只有一个为 0， 不妨设 $a &#x3D;0$，则式 $\\mathrm{(2.4.1)}$的特征方程 $\\mathrm{(2.4.8)}$ 可以写成：$$a\\left({\\frac{\\mathrm{d}y}{\\mathrm{d}x}}\\right)^2 -2b\\left(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right) + c &#x3D; 0\\tag{2.4.9}$$\n\n式 $\\mathrm{(2.4.9)}$ 看作一个一元二次方程，其 $\\delta &#x3D;b^2-ac$ 。接下来就对 $\\delta$ 分情况讨论。\ncase1. $\\delta&gt;0$大于0的前提是在 $(x_0, y_0)$ 附近\n此一元二次方程有2个根，我们也就可以把式 $\\mathrm{(2.4.9)}$ 看作 2 个方程：$$\\begin{aligned}\\frac{\\mathrm{d}y}{\\mathrm{d}x} &amp;&#x3D; \\frac{b + \\sqrt{\\delta}}{a}(x,y)\\\\frac{\\mathrm{d}y}{\\mathrm{d}x} &amp;&#x3D; \\frac{b - \\sqrt{\\delta}}{a}(x,y)\\\\end{aligned}\\tag{2.4.10}$$由常微分方程解的存在唯一性，式 $\\mathrm{(2.4.9)}$ 有 2 个解： $y &#x3D; y_k(x; C); k &#x3D; 1, 2$，其初始条件为 $y(x_0) &#x3D; y_0+C$ （初始位置加一个小搅动）。\n\nQ: 为什么初始条件要加一个小搅动？A: 讨论的区域是在 $(x_0, y_0)$ 附近，并非严格的 $(x_0, y_0)$ 点。\n\n上面的解是一个显式表达，x, y 地位不平等。我们希望求得隐式表达，好给式 $\\mathrm{(2.4.8)}$。\n因此，下面把 $y &#x3D; y_k(x;C)$ 变成 $\\varphi_k(x, y) &#x3D;C$ 的形式。（用隐函数存在定理）\n在方程式 $\\mathrm{(2.4.10)}$ 和初始条件两边对 $C$ 求导：$$\\begin{cases}\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{\\partial y}{\\partial C}\\right) &#x3D; \\frac{\\partial }{\\partial y} \\left(\\frac{b \\pm \\sqrt{\\delta}}{a}(x, y)\\right)\\frac{\\partial y}{\\partial C}\\\\frac{\\partial y}{\\partial C}(x_0; C) &#x3D; 1\\end{cases}$$\n这是一个关于 $\\frac{\\partial y}{\\partial C}$ 的一阶线性常微分方程问题，可以解得：$$\\frac{\\partial y}{\\partial C} &#x3D; \\exp\\left(\\int_{x_0}^x\\frac{\\partial}{\\partial y}\\left(\\frac{b\\pm\\sqrt{\\delta}}{a}\\left(\\xi, y(\\xi, C)\\right)\\mathrm{d} \\xi\\right)\\right) &gt; 0$$（不用管里面解出来是什么，只要不为 0 就行）\n\n求隐函数：要求谁，对谁求导。求 $y$，因此对 $y$ 求导。\n\n由隐函数存在定理，从式 $\\mathrm{(2.4.10)}$ 可以解出 $C&#x3D;\\varphi_k(x, y)$ ， $C$ 满足式 $\\mathrm{(2.4.7)}$ \n现在我们相当于求到了之前 $\\mathrm{(2.4.7)}$ 里的 $\\varphi_1, \\varphi_2$，还需要验证 Jacobi 行列式以确保可逆变换。\n\n            验证 Jacobi 行列式对 $y &#x3D; y_k(x; \\varphi_k(x, y))$ 两边分别对 $x, y$ 求导：$$0 &#x3D; \\frac{\\partial y_k}{\\partial x} + \\frac{\\partial y_k}{\\partial C}\\varphi_{kx}(x,y)\\quad 1 &#x3D; \\frac{\\partial y_k}{\\partial C}\\varphi_{ky}$$在 $(x_0, y_0)$ 附近时（感觉应该是指 $x&#x3D;x_0$ 时）$y(x_0) &#x3D; y_0+C$，$\\frac{\\partial y_k(x_0, C)}{\\partial C} &#x3D; \\frac{\\partial}{\\partial C}(y_0+C) &#x3D; 1$：$$\\varphi_{kx} &#x3D; -\\frac{\\partial y_k}{\\partial x} &#x3D; -y_k’, \\quad \\varphi_{ky} &#x3D; 1$$故Jacobi 非 0。\n          \n\n 结论：当我们求出来 式 $\\mathrm{(2.4.8)}$ 的隐式解之后，令 $\\xi &#x3D; \\varphi_1(x, y), \\eta &#x3D; \\varphi_2(x,y)$，从而式 $\\mathrm{(2.4.5)}$ 中的 $A&#x3D;C&#x3D;0$，式 $\\mathrm{(2.4.4)}$ 写成： $$ {\\color{red}{\\Huge U_{\\xi\\eta}} &#x3D; D_1U_{\\xi} + E_1U_{\\eta} + F_1U + G_1, \\tag{2.4.10}} $$\n\n            例化简并求解方程：$$4u_{xx} + 5u_{xy} + u_{yy} + u_x + u_y = 2$$---论化简，step1，列出形如 式 $\\mathrm{(2.4.9)}$ 的式子。step2，判断 $\\delta$ 与 0 的关系。step3，解一元二次方程step4，解常微分方程得 $y$ 的表达式 $y(x, C)$。step5，令 $\\xi=\\varphi_1(x, y), \\eta = \\varphi_2(x,y)$，然后把 $x,y$ 用 $\\xi, \\eta$ 表示出来。step6，用 $u, U$ 表达。  解： 观察可得 $a &#x3D; 4, b&#x3D; \\frac25, c&#x3D; 1$，$\\delta &#x3D; b^2-ac&gt;0$。故有： $$4\\left(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right)^2 - 5\\left(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right) + 1 &#x3D; 0 $$ 解得： $$\\frac{\\mathrm{d}y}{\\mathrm{d}x} &#x3D; 1 或 \\frac14 $$解 $\\mathrm{d}x, \\mathrm{d}y$ 的常微分方程，得：$$&#x3D; \\frac14x+C 或 y &#x3D; x+C$$也即：$$C&#x3D; -\\frac14x+y 或 C &#x3D; -x + y$$令 $\\xi &#x3D; -\\frac14x+y, \\eta &#x3D; -x+y$ ，则 $u(x, y) &#x3D; U(y-x, y - \\frac{x}{4})$。$$\\frac{\\partial u}{\\partial x} &#x3D; \\frac{\\partial U}{\\partial \\xi}\\frac{\\partial \\xi}{\\partial x} + \\frac{\\partial U}{\\partial\\eta}\\frac{\\partial \\eta}{\\partial x} &#x3D; -U_{\\xi} -\\frac14 U_{\\eta}$$同理可得：$$\\begin{gather}u_y &#x3D; U_{\\xi} + U_{\\eta}\\u_{xx} &#x3D; U_{\\xi\\xi}+\\frac12U_{\\xi\\eta} + \\frac{1}{16}U_{\\eta\\eta}\\u_{xx} &#x3D; -U_{\\xi\\xi}-\\frac54U_{\\xi\\eta} - \\frac{1}{4}U_{\\eta\\eta}\\u_{xx} &#x3D; U_{\\xi\\xi}+2U_{\\xi\\eta} + U_{\\eta\\eta}\\\\end{gather}$$把小写 $u$ 全部替换成大写 $U$ 得：$$-\\frac94U_{\\xi\\eta} +\\frac34U_{\\eta} &#x3D; 2$$即：$$U_{\\xi\\eta} &#x3D; \\frac13U_{\\eta} - \\frac89$$关于求解：先把上式写成：$$\\left(U_{\\eta}e^{-\\frac13\\xi}\\right)_{\\xi} &#x3D; -\\frac89e^{-\\frac13\\xi}$$两边再积分：$$U &#x3D; \\frac83\\eta+e^{\\frac{\\xi}{3}}h(\\eta) + g(\\xi)$$\n          \n\n\n一定要注意 $b$ 的含义有不同。原始的求根公式里的 b 对应应该是 $2b(x, y)$ 。\n\ncase2. $\\delta\\equiv0$前提： 在 $(x_0, y_0)$ 附近恒为 0，如果只是零点，不一定可以做下面的化简。\n此时式 $\\mathrm{(2.4.9)}$ 就成了 1 个方程，只能解出一个 $\\varphi$ 。还是在 $(x_0, y_0)$ 处：$$\\varphi_{1x} &#x3D; -\\frac{\\partial y(x_0)}{\\partial x}, \\quad \\varphi_{1y} &#x3D; 1$$为了让 Jacobi 非零，主动取 $\\varphi_2 &#x3D; x$，此时 $A &#x3D; B &#x3D; 0$，从而式 $\\mathrm{(2.4.4)}$ 写成：\n $$ {\\color{red}{\\Huge U_{\\eta\\eta} }&#x3D; D_2U_{\\xi} + E_2U_{\\eta} + F_2U + G_2, \\tag{2.4.11}} $$\ncase3. 在$(x_0, y_0)$ 附近 $\\delta&lt;0$此时式 $\\mathrm{(2.4.9)}$ 可以看作 2 个方程（1 个实方程， 1 个虚方程）。考虑其中的一个方程（共轭，所以另一个类似），我们可以假设：$$y &#x3D; \\Big[g(x)+C_1\\Big] + \\Big[h(x)+C_2\\Big] i$$\n写成隐函数的形式：$$\\varphi(x, y) &#x3D; C_1+iC_2 &#x3D; \\underbrace{\\Big[y-g(x)\\Big]}{\\varphi_1} + \\underbrace{\\Big[-h(x)\\Big]}{\\varphi_2}i$$\n根据复变函数的求导法则^ref2：\n$$\\frac{\\mathrm{d}y}{\\mathrm{d}x} &#x3D; \\frac{\\mathrm{d}g(x)}{\\mathrm{d}x} + i\\frac{\\mathrm{d}h(x)}{\\mathrm{d}x}$$因而对于上面的式子：\n$$\\begin{align}\\varphi_{1x} &amp;&#x3D; -\\frac{\\mathrm{d}g(x)}{\\mathrm{d} x} &#x3D; \\left(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right){\\mathrm{real}}\\\\varphi{1y} &amp;&#x3D; 1\\\\varphi_{2x} &amp;&#x3D; -\\frac{\\mathrm{d}h(x)}{\\mathrm{d}x} &#x3D; \\left(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right){\\mathrm{image}}&#x3D;-\\frac{\\pm\\sqrt{\\delta}}{a}\\\\varphi{2y} &amp;&#x3D; 0\\end{align}$$\n\n注：有一点我没有太明白，PPT上这里是在 $(x_0, y_0)$ （or 在其邻域？）的时候得到的结果，我上面的推导正确吗？\n\n在之后的替换中，用 $\\xi &#x3D; \\varphi_1, \\eta &#x3D; \\varphi_2$，就可以得到 $A &#x3D; C \\ne 0, B &#x3D; 0$，故式 $\\mathrm{(2.4.4)}$ 写成：\n $$ {\\color{red}{\\Huge U_{\\xi\\xi}+U_{\\eta\\eta} }&#x3D; D_3U_{\\xi} + E_3U_{\\eta} + F_3U + G_3, \\tag{2.4.12}} $$\n\nQ：为什么只考虑一个方程？A：因为两个方程共轭。共轭只影响 $$\\varphi&#x3D;\\varphi_1{\\color{red}\\pm}\\varphi_2i$$里红色的符号，最后替换为 $\\xi, \\eta$ 之后，我们也要实部虚部分开看。不影响结果。\n\n分类以之前的 $\\delta$ 为分类标准（可以证明式 $\\mathrm{(2.4.1)}$ 的 $\\delta$ 和式 $\\mathrm{(2.4.4)}$ 的 $\\Delta$ 在 $Jacobi\\ne 0$ 时符号相同）。\n\n$\\delta&gt;0$ ：双曲型，其标准型为式 $\\mathrm{(2.4.10)}$。\n$\\delta&#x3D;0$ ：抛物型，其标准型为式 $\\mathrm{(2.4.11)}$。\n$\\delta&lt;0$ ：椭圆型，其标准型为式 $\\mathrm{(2.4.12)}$。\n\n","categories":["笔记","数学"],"tags":["default"]},{"title":"数电总结1","url":"/posts/e6683f03/","content":"\n\n数制与码制这部分基本上是学习计算机相关课程所需要的必要内容，但同时也意味着，你可以在其它地方学到本部分的内容。\n数制的定义： 包含每一位由什么构成和从低位到高位的进位规则\n进制转换在大学所学的进制转换中，除了整数需要转换，还有小数需要转换。\n2-8-16最简单：2进制(Binary)、16进制(Hexadecimal)、8进制(Octal)之间的相互转换。\n只需要注意：整数部分不够在高位补0，小数部分不够在末位补0\n10-2整数部分：除2法（看余数，倒序）\n\n\n\n\n小数部分：乘2法（看每次乘出来的整数位，正序）\n\n\n\n\n2-10就是2的次幂相乘相加\n机内存储码在计算机中有4种存储码：原码、反码、补码、移码\n常用的是补码和移码，但移码不考，主要考补码\n\n如何补码与原码之间的相互转换？\n不管是补码转原码还是原码转补码，都是取反再加1。不过需要注意，符号位不动\n\n减法原码、反码：老老实实减。\n补码：转换为加法\n乘法加法+左移\n除法减法+移（如果用补码就变成加法+移）\n代码和编码BCD用4位二进制数来表示1位十进制数中的0~9这10个数码的都是BCD。可以分为2大类：恒权码和变权码。\n像8421码,5421,2421等都是恒权码。\n而变权码的代表是余3码和余3循环码\n余3码余3码，就是在8421码的基础上，每一个二进制数对应加上3，比如十进制中的0，在余3码中，对应的就是0011。\n余3循环码余3循环码，是在余3码的基础上，进行求格雷码的异或运算（从左到右，第一位相等，余3码的第二位开始与前一位进行异或运算求得余3循环码该位的值）。比如，十进制的0，余3码中对应的是0011，余三循环码中对应的就是0010。\n这样可以拥有Gray码的主要特性\nGray码校验码这里又有学问了。不过数电讲的不多，后面再补充。\n奇偶校验码只有一位校验码\n奇(odd)校验码： 信息码和校验码中的1为奇数。\n偶(even)校验码： 信息码和校验码中的1为偶数。\nASCII码搞计算机相关的一定学过。此处略。\n\n逻辑代数逻辑变量： 只有0和1\n逻辑函数： 逻辑变量运算的结果\n3种表示方式：表达式、真值表、逻辑符号（电路符号）\n","categories":["笔记","数字电路"],"tags":["default"]},{"title":"自动控制的基础","url":"/posts/f81506ce/","content":"\n\n\n\n控制系统的表示在自动控制领域，我们关心的是输出量这几个量的关系：\n\n我们给的输入量\n干扰量\n\n(系统的输出量与我们预计的输出量之间的差距，也是我们关心的部分，这个后面慢慢聊)\n要想看输出与输入之间的关系，最自然的一个想法就是把输入与输出写成一个函数。\n因此引出一个大的知识点：系统的微分方程与传递函数。\n微分方程列写系统的微分方程很简单，只需要分别对每个子环节列微分方程（可以需要借助中间变量），然后联立即可。\n例：\n\n例1设有一弹簧、质量块、阻尼器组成的系统如图所示，当外力$F$作用于系统时，系统将产生运动。建立外力F 与质量块位移y(t )之间的动态方程。其中弹簧的弹性系数为K，阻尼器的阻尼系数为f，质量块的质量为m。\n\n\n\n\n\n解 对质量块进行受力分析，作用在质量块上的力有\n\n外力: $F$\n弹簧回复力: $Ky(t)$\n阻尼力: $\\displaystyle f\\frac{\\mathrm{d}y(t)}{\\mathrm{d}t}$\n\n由牛顿第二定律得：$$m\\frac{\\mathrm{d}^2y(t)}{\\mathrm{d}t^2}+f\\frac{\\mathrm{d}y(t)}{\\mathrm{d}t} + Ky(t)&#x3D;F$$ \n\n传递函数在数学中如果有微分，会比较难以分析。于是我们可以利用Laplace变换把其变换到复数域上再进行分析，这样会方便很多。\n传递函数就是复数域下的输入输出关系函数\n既然需要用Laplace变换，我们的一个很重要的知识点就出来了——Laplace变换相关\nLaplace变换\n\n定义：\n$$\\begin{gather}L[f(t)]&#x3D;F(s) &#x3D; \\int_{0^-}^{+\\infty} f(t)e^{-st}\\mathrm{d}t \\quad(正变换)\\L^{-1}[F(s)] &#x3D; \\frac{1}{2\\pi j}\\int_{r-\\infty j}^{r+\\infty j } F(s)e^{st}\\mathrm{d}s (t&gt;0) \\quad(逆变换)\\end{gather}\\tag{1.1}\\label{def-laplace}$$\n这是的$s$是复数\n\n\n定义需要经常看。虽然直接用得少，但多半会考。\n然后是Laplace变换的一些性质：\nLaplace变换的性质定理线性无特别，略。\n积分与微分性质$s$可以看作微分算子的由来\n延迟性质$$\\begin{gather}L[f(t-t_0)]&#x3D;F(s)e^{-t_0s}\\end{gather}$$\n终值定理(重要)若$\\lim\\limits_{t\\to {\\color{red}\\infty}}f(t)$和 $\\lim\\limits_{s\\to {\\color{red}0}}sF(s)$都存在，则 $$\\begin{gather}\\lim_{t\\to {\\color{red}\\infty}}f(t)&#x3D;\\lim_{s\\to {\\color{red}0}}sF(s)\\end{gather}$$\n附常用的变换表\n\n\n原函数\n象函数\n\n\n\n$\\delta(1)$\n$1$\n\n\n$1(t)$\n$\\displaystyle \\frac{1}{s}$\n\n\n$t$\n$\\displaystyle \\frac{1}{s^2}$\n\n\n$\\sin \\omega t$\n$\\displaystyle \\frac{\\omega}{s^2+\\omega^2}$\n\n\n$\\cos \\omega t$\n$\\displaystyle \\frac{s}{s^2+\\omega^2}$\n\n\nR5C1\nR5C2\n\n\nR6C1\nR6C2\n\n\nR7C1\nR7C2\n\n\nR8C1\nR8C2\n\n\nR9C1\nR9C2\n\n\n动态结构图组成化简传递函数定义\n化简在结构图上化简Mason公式直接化简需要技巧，有没有更无脑的方法？Mason公式\n在公式之前有一些概念\n回路： loop\n互不接触回路： \nstep1 首先找到图里的loop，并求出每个loop的回环函数(G(s)H(s))(负反馈要带负号)\nstep2 分母：$1-\\sum\\text{独立的loop}+\\sum\\text{有1个相交的2个loop}+\\cdots$ （类似容斥）\nstep3 分子：$\\sum\\text{前向通道}\\times\\text{余因子}$\n","categories":["笔记","自动控制"],"tags":["Lagrange","Mason公式"]},{"title":"时域分析","url":"/posts/8db71ba5/","content":"本章重点：稳定性判断、系统响应的相关参数\n\n\n\n\n一阶系统二阶系统稳定性判据响应的相关参数","categories":["笔记","自动控制"],"tags":["一阶系统分析","二阶系统分析","时域分析","稳定性判据"]},{"title":"动态规划","url":"/posts/a80d0031/","content":"\n这篇文章，包括之后一系列的蓝桥杯文章都是在学习了代码随想录的公开内容之后的个人总结。\n十分推荐代码随想录这个网站，里面有不少信息竞赛的相关知识。虽然不是针对竞赛，但大部分内容是一样的，而且讲得很细。其在B站也有视频：代码随想录个人主页-哔哩哔哩视频。\n\n1 动态规划5步曲动态规划，可以看作是递推的一个推广。因此，一个问题能否用动态规划问题解决，需要看这个问题能否被分解为一个递推问题。具体来说，可以考虑如下的问题：\n\n能否分解为子问题？\n子问题与原问题是什么关系？\n\n当然，有的问题不一定一眼能看出来，我的习惯是先带入dp的方法来看，如果定义的dp数组可以写出递推公式，那大概率就可以用dp做。\n基本上，所有的dp问题的解决方法都可以归纳为如下的5步（来自代码随想录）：\n\n明确dp数组的定义；\n找递推公式；\ndp的初始化；\n遍历顺序；\n打印dp数组。\n\n我自己在此基础上修改了一些，变成了下面的这 5 步：\n\ndp定义；\n递推公式；\n结果形式（最后的输出是什么？是一个值还是一个等式）；\n初始条件；\n遍历顺序。\n\n经典问题一般有一个固定的模板（除了普通dp），这些模板的意义在于让我们看到这个问题之后能够较快的反应过来。但如果没有按照5步曲来做，没有理解5步曲里每一步在具体问题里的具体含义，背模板只能是表面上的会，如果题目变一下就不会做了。\n2 普通dp在力扣上的dp入门题如下：\n\n70 爬楼梯\n509 斐波那契数\n746 使用最小花费爬楼梯\n62 不同路径\n63 不同路径 II\n343 整数拆分\n96 不同的二叉搜索树\n\n这类dp问题的难点在于，分析出这些问题可以用dp，并正确写出dp数组的定义。如果有了dp数组的定义，后续的5步曲就相对容易了一点。\n比如96 不同的二叉搜索树，考虑一个相对一般的n，比如n&#x3D;3，当我们选择一个元素作为二叉搜索树的root后，其方案数就变成了子树方案数的排列组合，因此原问题就分解为了一个相同的子问题。\n3 背包问题背包问题最明显的特征是取数，在一个集合里取数。\n3.1 01背包\n            简单描述：有n个物品，每个物品有价值value和体积weight。我们需要选择一些物品到一个固定容量的背包，每个物品只能选择一次。问最大价值是多少。\n          \n\n3.1.1 基本解法step1，dp数组定义\n对于经典的01背包问题，可以定义dp数组dp[i][j]，含义是从第1个物品到第i个物品（根据数组的下标也可能是从0到i），当背包容量为j时的装的最大价值。\nstep2，递推公式\n假设当前是第 i 个物品，当前可用容量为 j ，现在有2种情况：\n\n不选第 i 个物品，那么最大价值就是上一个的最大价值：dp[i-1][j]；\n选第 i 个物品，那么就需要在上一个的最大价值（dp[i-1][j]）的基础上承受 weight[i] 的代价（体积），价值则增加了 value[i]，即dp[i-1][j - weight[i]] + value[i]\n\n也就是下面的公式：$$\\mathrm{dp}[i][j] &#x3D; \\max(\\mathrm{dp}[i-1][j], \\mathrm{dp}[i-1][j-\\mathrm{weight}[i]]+\\mathrm{value}[i])$$\nstep3，初始化\n现在的 dp 数组是一个二维数组，每一个值都由它正上面相邻的格子和正上方格子左侧的格子推导而得，因此我们需要初始化第 1 行和第 1 列。\n\n\n\n第 1 列的含义是：当可用容量为 0 时的最大价值。显然为 0。第 1 行的含义是：对于第 1 个物品，容量为 j 时的最大价值。如果 j 比 weight[0] 小，那一定是 0。而 j 比 weight[0] 大的所有格子，都应该为 value[0]。\nstep4，遍历顺序\n根据我刚才的图片，\n\n对于物品：只能从小到大。\n对于容量：可以从小到大，也可以从大到小。\n对于物品和容量之间：可以交换。\n\n具体的原理手动模拟一遍就可以了，不过多解释。\n\n3.1.2 状态压缩从刚才的遍历就可以发现，当前行只依赖于上一行，而且对右上角没有依赖。因此可以状态压缩。\n压缩后，dp 就成了 dp[j]。需要注意的是，此时的遍历顺序就固定了，没有可以交换的部分，即外层：物品从小到大，内层：容量从大到小。\n\n内外无法交换：只有行间是相邻的依赖，列与列之间的依赖跨行了。\n内层只能从大到小：行首的值会被行尾的用，因此只能先改行尾，再改行首。\n\n3.1.3 变体01背包常见的问法（变体）：\n\n尽量装满容器，求最大价值（当物品价值等于物品体积，就成了最多能装多少体积）；\n能不能装满容器；\n尽量装满容器的方案数。\n\n01背包问题，在容量上有这样的关系：$$\\mathrm{选的物品占的空间} \\le \\mathrm{背包容量} \\tag{2.2.1}$$\n如果物品的价值等于其自身的体积，那么背包问题求的最大价值就等价于求最大体积。\n\n            Leetcode 416.分割等和子集这题可以看作一个01背包问题，让$sum/2$的背包的最大价值（也即最大体积）等于$sum/2$，则式$\\mathrm{(2.2.1)}$的等号取等，则说明有分解方案。\n          \n\n3.2 完全背包完全背包， 之于 01 背包，最大的区别就在于其没有物品数量上的限制。在理解了基本的动态规划 5 步和 01 背包问题后，完全背包相对而言就很简单了。\n代码随想录的视频里说，区别就在：一维数组内层遍历的顺序改为从小到大。在这里，代码随想录里有解释为什么，但他用的是一维数组举的例子。我还是喜欢先用二维数组进行理解，而且我觉得二维数组更接近问题的本质一些。\n在二维中， 递推公式是：$$\\mathrm{dp}[i][j] &#x3D; \\max(\\mathrm{dp}[i-1][j] , \\mathrm{dp}[{\\color{red}i}][j-\\mathrm{w}[i]])$$\n\n\n这个公式表示，当前 dp 数组的值可以从这两个地方更新：\n\n当前物品一个都不选，则来自 $\\mathrm{dp}[i-1][j]$，\n当前物品要选，但不知道选多少个。则来自 $\\mathrm{dp}[i][j-\\mathrm{w}[i]]$。\n\n为什么当前不知道选多少个时可以从 $\\mathrm{dp}[i][j-\\mathrm{w}[i]]$ 更新？这是其实是把问题给分解了。我们在考虑 dp 递推公式时，考虑的是一个子问题，而不是一些子问题的组合。\n比如以上面的图为例，当前的子问题和 01 背包问题的子问题很像，都是看：选第 i 个物品而容量为 j 时的价值如何从相邻的状态里获得。\n在 01 背包和完全背包中，dp数组的定义没变，但 01 背包中，左边的箭头是从左上到右下，是因为当前物品只能选一次，如果要选物品 i ，那么选之前的状态只能是 还没有选物品 i 的，也就是 i-1。\n而在完全背包中，如果要选物品 i ，那么选之前的状态可能来自 还没选 ，也可能来自 选了一个，又想选一个。同时，选了一个，又想选一个 的状态已经把 还没选 的状态也包括了，也就是 $\\mathrm{dp}[{\\color{red}i}][j-\\mathrm{w}[i]]$ 包括了 $\\mathrm{dp}[{\\color{green}i-1}][j-\\mathrm{w}[i]]$，因此箭头直接变成了从左向右。\n如果理解了这个，也就不难理解为什么状压之后内层（背包容量）的遍历顺序是正向的了。\n另外，当问题是求最大价值时，内层和外层可以交换遍历顺序。如果是其它的（如组合数，或排列数），则不一定能交换，需要具体分析。\n\n            Leetcode 518.零钱兑换II此题是一道完全背包问题。dp数组的定义为是总方案数（排列组合里的组合），这里内层外层就不能交换。如果交换就成了求排列数了。\n          \n","categories":["蓝桥杯","动态规划"],"tags":["default","未完"]},{"title":"扩展欧几里德","url":"/posts/82456769/","content":"","categories":["蓝桥杯","数论"],"tags":["default","未完"]}]